<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I | O</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* Base Styles (sin cambios significativos, ya los tienes bien) */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap');
        html, body {
            margin: 0; padding: 0; height: 100%; overflow: hidden; position: relative; background-color: black;
            font-family: 'Space Mono', monospace; color: white;
        }
        canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; z-index: 0;
        }
        #app-container {
            position: relative; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; z-index: 1;
            /* Adjust padding to make space for fixed elements, will be overridden for mobile */
            padding-top: 7rem; padding-bottom: 5rem; padding-left: 300px; padding-right: 300px; box-sizing: border-box;
        }

        /* --- Global UI Containers (Responsivo) --- */
        .header-container, .footer-container {
            position: fixed; left: 50%; transform: translateX(-50%);
            width: auto; min-width: 300px; text-align: center; padding: 1rem 1.5rem;
            background-color: transparent; box-shadow: none; z-index: 10;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            box-sizing: border-box;
        }
        .header-container { top: 0; }
        .footer-container { bottom: 0; }
        .header-container.hidden { transform: translateX(-50%) translateY(-150%); opacity: 0; pointer-events: none; }
        .footer-container.hidden { transform: translateX(-50%) translateY(150%); opacity: 0; pointer-events: none; }
        .left-sidebar-container, .right-sidebar-container {
            position: fixed; top: 7rem; height: calc(100% - 7rem - 5rem); width: 300px;
            background-color: rgba(0, 0, 0, 0.8); z-index: 9; display: flex; flex-direction: column; padding: 0.75rem;
            box-sizing: border-box; transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        .left-sidebar-container { left: 0; border-right: 1px solid white; border-top-right-radius: 0.75rem; border-bottom-right-radius: 0.75rem; }
        .right-sidebar-container { right: 0; border-left: 1px solid white; border-top-left-radius: 0.75rem; border-bottom-left-radius: 0.75rem; }
        .left-sidebar-container.hidden { transform: translateX(-100%); opacity: 0; pointer-events: none; }
        .right-sidebar-container.hidden { transform: translateX(100%); opacity: 0; pointer-events: none; }
        .page.hidden { opacity: 0; pointer-events: none; display: none; }

        /* Mobile Specific Styles (media query para pantallas chicas) */
        @media (max-width: 768px) {
            /* Full-screen UI containers (no padding) */
            #app-container {
                padding-left: 0;
                padding-right: 0;
            }

            /* Show UI elements from the top for better accessibility */
            .header-container, .footer-container {
                position: fixed;
                left: 0;
                transform: none;
                width: 100%;
                min-width: unset;
                padding: 1rem;
            }

            /* Sidebars go full width and occupy half screen height from top/bottom */
            .left-sidebar-container, .right-sidebar-container {
                top: unset;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                height: 50vh; /* Half of viewport height */
                padding: 1rem;
                border-left: none;
                border-right: none;
                border-top: 1px solid white;
                border-radius: 0;
                transform: translateY(100%); /* Start hidden from the bottom */
                transition: transform 0.3s ease-in-out;
            }
            .left-sidebar-container.active, .right-sidebar-container.active {
                transform: translateY(0); /* Slide up to be visible */
            }

            /* We need a button to toggle the menus */
            #sidebarToggleLeft, #sidebarToggleRight {
                display: block; /* Show the button on mobile */
                position: fixed;
                z-index: 20;
                top: 1rem;
                width: 40px;
                height: 40px;
                font-size: 1.5rem;
                background-color: rgba(255, 255, 255, 0.2);
                border: 1px solid white;
                border-radius: 8px;
            }
            #sidebarToggleLeft { left: 1rem; }
            #sidebarToggleRight { right: 1rem; }
            .right-sidebar-container.hidden, .left-sidebar-container.hidden {
                opacity: 1; /* Keep opacity at 1 for slide effect */
                pointer-events: auto; /* Allow clicks to open the menu */
            }

            /* Adjustments for specific elements */
            .profile-page-content {
                margin-top: 5rem; /* Space from the top header */
                padding: 1rem;
            }
            #audioDebugInfo {
                right: 1rem;
                top: 5rem;
                padding: 0.25rem;
                font-size: 0.6rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="visualCanvas"></canvas>

    <div id="app-container">
        <div id="mainVisualizerPage" class="page active">
            <button id="sidebarToggleLeft" class="btn hidden">
                <i class="fas fa-sliders-h"></i>
            </button>
            <button id="sidebarToggleRight" class="btn hidden">
                <i class="fas fa-filter"></i>
            </button>

            <div class="header-container" id="headerContainerMain">
                <h1>I | O</h1>
                <p class="description">"signal in, chaos out"</p>
                <p class="description-sub">música experimental + visuales</p>
                <div class="social-buttons">
                    <a href="https://www.tiktok.com/@juca.noiz" target="_blank" class="social-btn"><i class="fab fa-tiktok"></i></a>
                    <a href="https://www.instagram.com/jucanoiz/" target="_blank" class="social-btn"><i class="fab fa-instagram"></i></a>
                    <a href="https://www.facebook.com/juca.noiz.2025" target="_blank" class="social-btn"><i class="fab fa-facebook-f"></i></a>
                </div>
            </div>

            <div class="left-sidebar-container hidden" id="leftSidebarContainer">
                <div class="main-controls-scrollable">
                    <div class="control-group-box">
                        <h3>modo visual</h3>
                        <div class="control-group">
                            <label for="visualMode">seleccionar modo:</label>
                            <select id="visualMode" class="btn mappable-control" data-midi-target="visualMode">
                                <option value="spheres">esferas pulsantes</option>
                                <option value="particles">partículas reactivas</option>
                                <option value="waves">ondas de color</option>
                                <option value="cubes">cubos giratorios</option>
                                <option value="audioBars">barras de audio</option>
                                <option value="torus">toroides múltiples</option>
                                <option value="torusKnot">nudo toroide</option>
                                <option value="dodecahedron">dodecaedros múltiples</option>
                                <option value="icosahedron">icosaedros múltiples</option>
                                <option value="octahedron">octaedros múltiples</option>
                                <option value="cone">conos múltiples</option>
                                <option value="cylinder">cilindros múltiples</option>
                                <option value="ring">anillos múltiples</option>
                                <option value="tetrahedron">tetraedros múltiples</option>
                                <option value="multiTorus">multi-toroides</option>
                                <option value="gyroscope1">giroscopio de anillos</option>
                                <option value="gyroscope2">giroscopio de esferas anidadas</option>
                                <option value="gyroscope3">giroscopio de toroides intersectados</option>
                                <option value="fractalNoise">ruido fractal</option>
                                <option value="hydraFuego">hydra fuego cósmico</option>
                                <option value="hydraGlitch">hydra glitch dimension</option>
                                <option value="hydraTunel">hydra túnel espacial</option>
                            </select>
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>controles de visualización</h3>
                        <div class="control-group">
                            <label for="colorSpeed">vel. color:</label>
                            <input type="range" id="colorSpeed" min="0.01" max="0.5" step="0.01" value="0.1" class="mappable-control" data-midi-target="colorSpeed">
                        </div>
                        <div class="control-group">
                            <label for="amplitudeSensitivity">sens. audio general:</label>
                            <input type="range" id="amplitudeSensitivity" min="0.1" max="5.0" step="0.1" value="1.0" class="mappable-control" data-midi-target="amplitudeSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="audioReactionThreshold">umbral audio (db):</label>
                            <input type="range" id="audioReactionThreshold" min="0" max="255" step="1" value="45" class="mappable-control" data-midi-target="audioReactionThreshold">
                        </div>
                        <div class="control-group">
                            <label for="bassSensitivity">sens. graves:</label>
                            <input type="range" id="bassSensitivity" min="0.1" max="5.0" step="0.1" value="1.0" class="mappable-control" data-midi-target="bassSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="midSensitivity">sens. medios:</label>
                            <input type="range" id="midSensitivity" min="0.1" max="5.0" step="0.1" value="1.0" class="mappable-control" data-midi-target="midSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="trebleSensitivity">sens. agudos:</label>
                            <input type="range" id="trebleSensitivity" min="0.1" max="5.0" step="0.1" value="1.0" class="mappable-control" data-midi-target="trebleSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="layerOpacity">opacidad capa:</label>
                            <input type="range" id="layerOpacity" min="0.1" max="1.0" step="0.05" value="1.0" class="mappable-control" data-midi-target="layerOpacity">
                        </div>
                        <div class="control-group">
                            <label for="shapeScale">escala global:</label>
                            <input type="range" id="shapeScale" min="0.1" max="2.0" step="0.05" value="1.0" class="mappable-control" data-midi-target="shapeScale">
                        </div>
                        <div class="control-group">
                            <label for="deformationLevel">nivel deformación:</label>
                            <input type="range" id="deformationLevel" min="0.0" max="1.0" step="0.01" value="0.5" class="mappable-control" data-midi-target="deformationLevel">
                        </div>
                        <div class="control-group">
                            <label for="materialMode">modo material:</label>
                            <input type="range" id="materialMode" min="0" max="2" step="1" value="0" class="mappable-control" data-midi-target="materialMode">
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>opciones de color y más</h3>
                        <div class="checkbox-group">
                            <input type="checkbox" id="grayscaleToggle" class="mappable-control" data-midi-target="grayscaleToggle">
                            <label for="grayscaleToggle">escala de grises figuras</label>
                        </div>
                        <div class="color-palette">
                            <label>colores custom:</label>
                            <div class="color-input-group">
                                <input type="color" id="color1" value="#FF0000" class="mappable-control" data-midi-target="color1">
                                <input type="color" id="color2" value="#00FF00" class="mappable-control" data-midi-target="color2">
                                <input type="color" id="color3" value="#0000FF" class="mappable-control" data-midi-target="color3">
                            </div>
                            <div class="color-input-group">
                                <input type="color" id="color4" value="#FFFF00" class="mappable-control" data-midi-target="color4">
                                <input type="color" id="color5" value="#FF00FF" class="mappable-control" data-midi-target="color5">
                                <input type="color" id="color6" value="#00FFFF" class="mappable-control" data-midi-target="color6">
                            </div>
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>dispositivos de entrada</h3>
                        <div class="control-group">
                            <label for="audioInputSelect">entrada de audio:</label>
                            <select id="audioInputSelect" class="btn mappable-control" data-midi-target="audioInputSelect"></select>
                        </div>
                        <div class="control-group">
                            <label for="cameraSelect">seleccionar cámara:</label>
                            <select id="cameraSelect" class="btn mappable-control" data-midi-target="cameraSelect"></select>
                        </div>
                    </div>

                    <div class="control-group-box actions-box">
                        <h3>acciones</h3>
                        <button id="toggleAudio" class="btn mappable-control" data-midi-target="toggleAudio">activar audio</button>
                        <div class="file-input-wrapper">
                            <button class="btn">cargar imagen</button>
                            <input type="file" id="imageUpload" accept="image/*" multiple>
                        </div>
                        <button id="clearImageBtn" class="btn mappable-control" data-midi-target="clearImageBtn">borrar imagen de fondo</button>
                        <button id="fullscreenBtn" class="btn mappable-control" data-midi-target="fullscreenBtn">pantalla completa</button>
                    </div>
                </div>
            </div>

            <div class="right-sidebar-container hidden" id="rightSidebarContainer">
                <div class="main-controls-scrollable">
                    <div class="control-group-box">
                        <h3>filtros de imagen de fondo</h3>
                        <div class="color-input-group">
                            <label for="chromaKeyColor">color chroma key:</label>
                            <input type="color" id="chromaKeyColor" value="#00FF00" class="mappable-control" data-midi-target="chromaKeyColor">
                        </div>
                        <div class="control-group">
                            <label for="chromaKeyThreshold">umbral chroma key:</label>
                            <input type="range" id="chromaKeyThreshold" min="0.0" max="0.5" step="0.01" value="0.001" class="mappable-control" data-midi-target="chromaKeyThreshold">
                        </div>
                        <div class="control-group">
                            <label for="backgroundScaleSlider">escala de fondo:</label>
                            <input type="range" id="backgroundScaleSlider" min="0.5" max="5.0" step="0.1" value="1.5" class="mappable-control" data-midi-target="backgroundScaleFactor">
                        </div>
                        <div class="control-group">
                            <label for="hueRotateSlider">rotación de tono:</label>
                            <input type="range" id="hueRotateSlider" min="0" max="360" step="1" value="0" class="mappable-control" data-midi-target="hueRotate">
                        </div>
                        <div class="control-group">
                            <label for="saturationSlider">saturación:</label>
                            <input type="range" id="saturationSlider" min="0" max="200" step="1" value="100" class="mappable-control" data-midi-target="saturation">
                        </div>
                        <div class="control-group">
                            <label for="vignetteSlider">viñeta:</label>
                            <input type="range" id="vignetteSlider" min="0" max="100" step="1" value="0" class="mappable-control" data-midi-target="vignette">
                        </div>
                        <div class="control-group">
                            <label for="posterizeSlider">posterizar:</label>
                            <input type="range" id="posterizeSlider" min="2" max="255" step="1" value="255" class="mappable-control" data-midi-target="posterize">
                        </div>
                        <div class="control-group">
                            <label for="sharpenSlider">nitidez:</label>
                            <input type="range" id="sharpenSlider" min="0" max="10" step="0.1" value="0" class="mappable-control" data-midi-target="sharpen">
                        </div>
                        <div class="control-group">
                            <label for="scanlineSlider">líneas de escaneo:</label>
                            <input type="range" id="scanlineSlider" min="0" max="100" step="1" value="0" class="mappable-control" data-midi-target="scanline">
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>controles de cámara</h3>
                        <button id="startCameraBtn" class="btn mappable-control" data-midi-target="startCameraBtn">activar cámara</button>
                        <button id="stopCameraBtn" class="btn mappable-control" data-midi-target="stopCameraBtn">detener cámara</button>
                        <div class="control-group">
                            <label for="cameraFilterModeSelect">filtro base:</label>
                            <select id="cameraFilterModeSelect" class="btn mappable-control" data-midi-target="cameraFilterModeSelect">
                                <option value="0">ninguno</option>
                                <option value="1">escala de grises</option>
                                <option value="2">invertir colores</option>
                                <option value="3">sepia</option>
                                <option value="4">pixelado</option>
                                <option value="5">desenfoque</option>
                                <option value="6">solo bordes</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="cameraNoiseSlider">ruido bordes:</label>
                            <input type="range" id="cameraNoiseSlider" min="0" max="100" value="0" class="mappable-control" data-midi-target="cameraNoiseAmount">
                        </div>
                        <div class="control-group">
                            <label for="cameraEdgeSensitivitySlider">sensibilidad bordes:</label>
                            <input type="range" id="cameraEdgeSensitivitySlider" min="0" max="100" value="50" class="mappable-control" data-midi-target="cameraEdgeSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="cameraBrightnessSlider">brillo:</label>
                            <input type="range" id="cameraBrightnessSlider" min="-100" max="100" value="0" class="mappable-control" data-midi-target="cameraBrightness">
                        </div>
                        <div class="control-group">
                            <label for="cameraContrastSlider">contraste:</label>
                            <input type="range" id="cameraContrastSlider" min="0" max="100" value="50" class="mappable-control" data-midi-target="cameraContrast">
                        </div>
                        <div class="control-group">
                            <label for="cameraPixelateSizeSlider">tamaño pixel:</label>
                            <input type="range" id="cameraPixelateSizeSlider" min="1" max="50" value="1" class="mappable-control" data-midi-target="cameraPixelateSize">
                        </div>
                        <div class="control-group">
                            <label for="cameraBlurAmountSlider">intensidad desenfoque:</label>
                            <input type="range" id="cameraBlurAmountSlider" min="0" max="10" value="0" class="mappable-control" data-midi-target="cameraBlurAmount">
                        </div>
                        <div class="control-group">
                            <label for="cameraMaterialSelect">tinte bordes:</label>
                            <select id="cameraMaterialSelect" class="btn mappable-control" data-midi-target="cameraMaterialColor">
                                <option value="none">normal</option>
                                <option value="mercury">mercurio</option>
                                <option value="gold">oro</option>
                                <option value="lava">lava</option>
                                <option value="water">agua</option>
                            </select>
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>control midi</h3>
                        <div class="midi-control-group">
                            <label for="midiInputSelect">entrada midi:</label>
                            <select id="midiInputSelect"></select>
                        </div>
                        <div class="midi-control-group">
                            <label for="midiOutputSelect">salida midi (futuro):</label>
                            <select id="midiOutputSelect"></select>
                        </div>
                        <div class="control-group">
                            <label for="midiChannelInput">canal midi (1-16):</label>
                            <input type="number" id="midiChannelInput" min="1" max="16" value="1">
                        </div>
                        <h3>modo de aprendizaje midi</h3>
                        <div class="midi-control-group">
                            <button id="startMidiLearnBtn" class="btn">iniciar aprendizaje midi</button>
                            <button id="stopMidiLearnBtn" class="btn" style="display: none;">detener aprendizaje midi</button>
                        </div>
                        <p id="midiLearnStatus" class="midi-learn-status">haz clic en un control visual para mapearlo.</p>
                        <h3>mapeos actuales</h3>
                        <button id="clearMidiMappingsBtn" class="btn">borrar todos los mapeos</button>
                        <table class="midi-mappings-table">
                            <thead>
                                <tr>
                                    <th>tipo midi</th>
                                    <th>canal</th>
                                    <th>número</th>
                                    <th>control visual</th>
                                    <th>acción</th>
                                </tr>
                            </thead>
                            <tbody id="midiMappingsTableBody"></tbody>
                        </table>
                        <h3>monitor midi</h3>
                        <div id="midiMonitor" class="midi-monitor"></div>
                    </div>
                </div>
            </div>

            <div class="footer-container" id="footerContainer">
                <p class="footer-text">creado por juca noiz | aural flux®</p>
                <div class="profile-buttons">
                    <button id="jucaProfileBtn" class="profile-btn">JuCa Noiz</button>
                    <button id="maroProfileBtn" class="profile-btn">Maro Valdivia</button>
                </div>
            </div>
        </div>

        <div id="jucaPage" class="page hidden">
            <div class="header-container">
                <h1>I | O</h1>
                <p class="description">JuCa Noiz</p>
                <p class="description-sub">ingeniero y diseñador de experiencias</p>
            </div>
            <div class="profile-page-content">
                <h2>perfil de JuCa Noiz</h2>
                <h3>biografía</h3>
                <p>JuCa Noiz es un ingeniero y diseñador de experiencias, especializado en la creación de paisajes sonoros y la integración de audio con visuales interactivos. su enfoque se centra en cómo el sonido puede moldear y ser moldeado por entornos visuales, explorando la sinestesia digital.</p>
                <p>con una profunda comprensión de la acústica y el procesamiento de señales, JuCa aporta una perspectiva técnica y artística a proyectos que buscan fusionar la música experimental con la interactividad visual, creando atmósferas envolventes y multisensoriales.</p>
                <h3>proyectos destacados</h3>
                <ul>
                    <li>I | O Web: una plataforma interactiva para la generación de visuales en tiempo real, donde el sonido y los controles MIDI dan vida a experiencias inmersivas.</li>
                    <li>Participación como sintetista en Tech-Noch: explorando la fusión de la cultura digital con las raíces sonoras más profundas, ¡creando un desmadre sonoro y visual que te vuela la cabeza!</li>
                    <li>"Resonance Chambers": una serie de experimentos sonoros que utilizan la resonancia de espacios físicos para generar visuales reactivos.</li>
                    <li>"Glitch Garden": un entorno interactivo donde los sonidos de la naturaleza son procesados y visualizados como fallas digitales.</li>
                    <li>"Sonic Sculptures": colaboraciones con escultores para crear piezas que emiten y reaccionan a estímulos sonoros.</li>
                </ul>
                <h3>filosofía artística</h3>
                <p>JuCa cree que el sonido es una fuerza fundamental en la experiencia humana, capaz de evocar emociones y transformar la percepción. su trabajo busca amplificar esta fuerza, utilizando la tecnología para revelar la belleza oculta en el ruido y la armonía, creando diálogos entre lo audible y lo visible.</p>
            </div>
            <div class="back-btn-container">
                <button class="back-btn" data-target-page="mainVisualizerPage">volver</button>
            </div>
        </div>

        <div id="maroPage" class="page hidden">
            <div class="header-container">
                <h1>I | O</h1>
                <p class="description">Maro Valdivia</p>
                <p class="description-sub">artista audiovisual</p>
            </div>
            <div class="profile-page-content">
                <h2>perfil de Maro Valdivia</h2>
                <h3>biografía</h3>
                <p>originario de Ciudad de México, Omar Valdivia es un artista multidisciplinario que fusiona elementos tradicionales y contemporáneos para crear experiencias sonoras y visuales únicas. su obra trasciende los límites convencionales, combinando diversos géneros y estilos para ofrecer composiciones innovadoras y cautivadoras. su habilidad para integrar diferentes disciplinas lo convierte en un creador de experiencias únicas, reflejando su profunda comprensión del arte como un medio en constante evolución.</p>
                <h3>Tech-Noch</h3>
                <p>Tech-Noch es un proyecto que explora la cultura y la tecnología a través de herramientas como el videomapping, la música y la creación digital, para generar experiencias visuales y auditivas inmersivas. Tech-Noch sirve como un puente entre el pasado y el futuro, ofreciendo una experiencia que vincula a las personas con sus raíces culturales, al tiempo que exploran las infinitas posibilidades de la tecnología.</p>
                <h3>apariciones destacadas</h3>
                <ul>
                    <li>Cryptofest, Tulúm, Q. Roo: videomapping con video proyecciones de colaboradores de Arteknov, sobre hongo de palma y lasers proyectados en lago. colaboración con Tulaaart, Arteknov.</li>
                    <li>Festival Prisma, Mérida, Yucatán: participación con video proyecciones como apoyo para la carrera de diseño y nuevos medios en el Gran Museo del Mundo Maya. colaboración con Universidad Anáhuac Mayab, Tulaaart.</li>
                    <li>Festival Naltik, Zacatlán, Puebla: colección de templos y pirámides proyectados con laser en las nubes sobrepuesto a la ciudad de Zacatlán de las Manzanas. videomapping al templo del "Señor del Cable" de la serie "Bandalismo Espiritual". colaboración con Transductor, Black3Labs.</li>
                    <li>Panteon MX, CDMX, MX: videomapping para inauguración de exposición del STP Crew. colaboración con Transductor, N30, STP Crew, Maldita Carmen, Meme.ZP.3KTRA, Fabs, Alibe, Nomoneynohoney.</li>
                    <li>Nektar, CDMX, MX y Toluca, Edo. Mex.: pre-lanzamiento de bebida Purple Haze de la marca Nektar, fiesta para influencers y artistas. colaboración con Sinestechnia, NEUG, WTS, Noise Diva.</li>
                    <li>Festival Data Uotan, CDMX, MX: participación con videomapping interactivo colaboración de obra de Ricardo Santos "Cocodrilos" para Festival Data Uotan patrocinado por la Embajada de Paises Bajos en México. colaboración con Ricardo Santos, NEUG, Uncloud, Alejandra Metztli.</li>
                    <li>"Abundance", CDMX, MX: participación para RE:INTEGRA. modelo: Michelle Favreau, artista de pintura: Bella Schauer, fotógrafo: Summer Hokulani, proyección: Tech-Noch.</li>
                </ul>
                <h3>contacto</h3>
                <p>web: <a href="https://www.omargarciavaldivia.com" target="_blank" style="color: white; text-decoration: underline;">www.omargarciavaldivia.com</a></p>
                <p>instagram: <a href="https://www.instagram.com/omar_valdivia" target="_blank" style="color: white; text-decoration: underline;">@omar_valdivia</a> / <a href="https://www.instagram.com/tech_noch" target="_blank" style="color: white; text-decoration: underline;">@tech_noch</a></p>
                <p>email: <a href="mailto:OMAR.G.VALDIVIA@GMAIL.COM" style="color: white; text-decoration: underline;">omar.g.valdivia@gmail.com</a></p>
            </div>
            <div class="back-btn-container">
                <button class="back-btn" data-target-page="mainVisualizerPage">volver</button>
            </div>
        </div>
    </div>

    <div id="audioDebugInfo">
        amplitud audio: <span id="currentAmplitude">0</span><br>
        nivel reacción: <span id="normalizedReaction">0.00</span><br>
        graves: <span id="bassAmplitude">0</span><br>
        medios: <span id="midAmplitude">0</span><br>
        agudos: <span id="trebleAmplitude">0</span>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxOk">ok</button>
    </div>

    <script type="module">
       // --- Main Visualizer Three.js Init and Resize ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: visualCanvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Clear to transparent black
            renderer.setPixelRatio(window.devicePixelRatio);

            camera.position.z = 5;

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            const planeGeometry = new THREE.PlaneGeometry(2, 2); // A plane that covers the whole screen

            // Image/Camera Plane (unified background)
            imagePlane = new THREE.Mesh(planeGeometry, new THREE.ShaderMaterial({
                uniforms: {
                    backgroundTexture: { value: null },
                    isCameraActive: { value: false },
                    chromaKeyColor: { value: new THREE.Color(params.chromaKeyColor) },
                    chromaKeyThreshold: { value: params.chromaKeyThreshold },
                    backgroundFilterMode: { value: params.cameraFilterMode }, // Now uses cameraFilterMode
                    backgroundNoiseAmount: { value: params.cameraNoiseAmount },
                    backgroundEdgeSensitivity: { value: params.cameraEdgeSensitivity },
                    backgroundBrightness: { value: params.cameraBrightness },
                    backgroundContrast: { value: params.cameraContrast },
                    backgroundPixelateSize: { value: params.cameraPixelateSize },
                    backgroundBlurAmount: { value: params.cameraBlurAmount },
                    backgroundMaterialColor: { value: params.cameraMaterialColor },
                    audioVolume: { value: 0.0 }, // This will be updated from main analyser
                    time: { value: 0.0 },
                    // NEW IMAGE EFFECT UNIFORMS
                    uHueRotate: { value: params.hueRotate * Math.PI / 180.0 }, // Convert degrees to radians
                    uSaturation: { value: params.saturation / 100.0 }, // Normalize to 0-2
                    uVignette: { value: params.vignette / 100.0 }, // Normalize to 0-1
                    uPosterizeLevels: { value: params.posterize }, // Raw value 2-255
                    uSharpenAmount: { value: params.sharpen }, // Raw value 0-10
                    uScanlineDensity: { value: params.scanline / 100.0 }, // Normalize to 0-1
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D backgroundTexture;
                    uniform bool isCameraActive;
                    uniform vec3 chromaKeyColor;
                    uniform float chromaKeyThreshold;
                    uniform int backgroundFilterMode; // 0:none, 1:grayscale, 2:invert, 3:sepia, 4:pixelate, 5:blur, 6:edge-only
                    uniform float backgroundNoiseAmount;
                    uniform float backgroundEdgeSensitivity;
                    uniform float backgroundBrightness; // -1 to 1
                    uniform float backgroundContrast; // 0 to 2
                    uniform float backgroundPixelateSize;
                    uniform float backgroundBlurAmount;
                    uniform vec3 backgroundMaterialColor;
                    uniform float audioVolume;
                    uniform float time;

                    // NEW IMAGE EFFECT UNIFORMS
                    uniform float uHueRotate;
                    uniform float uSaturation;
                    uniform float uVignette;
                    uniform float uPosterizeLevels;
                    uniform float uSharpenAmount;
                    uniform float uScanlineDensity;

                    varying vec2 vUv;

                    // Simple hash function for random numbers in GLSL
                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                    }

                    // Perlin Noise (simplified)
                    float noise(vec2 st) {
                        vec2 i = floor(st);
                        vec2 f = fract(st);
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
                    }

                    // Grayscale conversion
                    float toGrayscale(vec3 color) {
                        return dot(color, vec3(0.299, 0.587, 0.114));
                    }

                    // Apply brightness and contrast
                    vec3 applyBrightnessContrast(vec3 color, float bright, float cont) {
                        color += bright; // Apply brightness
                        color = (color - 0.5) * cont + 0.5; // Apply contrast
                        return clamp(color, 0.0, 1.0);
                    }

                    // Apply sepia filter
                    vec3 applySepia(vec3 color) {
                        float r = color.r;
                        float g = color.g;
                        float b = color.b;
                        vec3 sepiaColor;
                        sepiaColor.r = min(1.0, (r * 0.393) + (g * 0.769) + (b * 0.189));
                        sepiaColor.g = min(1.0, (r * 0.349) + (g * 0.686) + (b * 0.168));
                        sepiaColor.b = min(1.0, (r * 0.272) + (g * 0.534) + (b * 0.131));
                        return sepiaColor;
                    }

                    // Hue Rotation
                    vec3 rgbToHsv(vec3 c) {
                        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                        float d = q.x - min(q.w, q.y);
                        float e = 1.0e-10;
                        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
                    }

                    vec3 hsvToRgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.x, 0.0, 1.0), c.y);
                    }

                    // Saturation
                    vec3 adjustSaturation(vec3 color, float sat) {
                        vec3 gray = vec3(dot(color, vec3(0.299, 0.587, 0.114)));
                        return mix(gray, color, sat);
                    }

                    // Vignette
                    vec3 applyVignette(vec3 color, float vignetteAmount) {
                        vec2 uv_centered = vUv - 0.5;
                        float dist = length(uv_centered);
                        float vignette = smoothstep(0.4, 0.8, dist); // Adjust these values for vignette size/falloff
                        return mix(color, color * (1.0 - vignetteAmount), vignette);
                    }

                    // Posterize
                    vec3 applyPosterize(vec3 color, float levels) {
                        return floor(color * levels) / levels;
                    }

                    // Sharpen (simple 3x3 convolution)
                    vec3 applySharpen(sampler2D tex, vec2 uv, float amount) {
                        vec2 texelSize = 1.0 / vec2(textureSize(tex, 0));
                        vec3 sum = vec3(0.0);

                        sum += texture2D(tex, uv + texelSize * vec2(-1, -1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2( 0, -1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2( 1, -1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2(-1,  0)).rgb * -0.07;
                        sum += texture2D(tex, uv).rgb * (1.0 + 8.0 * 0.07); // Center pixel weight
                        sum += texture2D(tex, uv + texelSize * vec2( 1,  0)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2(-1,  1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2( 0,  1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2( 1,  1)).rgb * -0.07;

                        return mix(texture2D(tex, uv).rgb, sum, amount);
                    }

                    // Scanline
                    vec3 applyScanline(vec3 color, float density) {
                        float scanline = sin(vUv.y * 500.0) * 0.05 * density; // 500 lines, 0.05 intensity
                        return color * (1.0 - scanline);
                    }


                    void main() {
                        vec4 texColor = texture2D(backgroundTexture, vUv);
                        vec3 finalColor = texColor.rgb;

                        // 1. Apply Chroma Key (only for images, not camera)
                        // If camera is active, chroma key is bypassed (assuming camera doesn't need it)
                        if (!isCameraActive) {
                            vec3 diff = finalColor - chromaKeyColor;
                            float dist = length(diff);
                            if (dist < chromaKeyThreshold) {
                                discard; // Make pixel transparent
                            }
                        }

                        // 2. Apply Brightness and Contrast (always apply)
                        finalColor = applyBrightnessContrast(finalColor, backgroundBrightness, backgroundContrast);

                        // 3. Apply Base Filter Mode OR Edge-Only Mode (Camera filters take precedence if camera is active)
                        if (isCameraActive && backgroundFilterMode == 6) { // 'edge-only' mode for camera
                            // Convert to grayscale for edge detection
                            float currentGray = toGrayscale(finalColor);
                            vec2 texelSize = 1.0 / vec2(textureSize(backgroundTexture, 0));
                            float gX = 0.0;
                            float gY = 0.0;

                            // Sobel operator kernels (simplified for 2D)
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, -1)).rgb) * -1.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, 0)).rgb) * -2.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, 1)).rgb) * -1.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, -1)).rgb) * 1.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, 0)).rgb) * 2.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, 1)).rgb) * 1.0;

                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, -1)).rgb) * -1.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + vec2(0, -1) * texelSize).rgb) * -2.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, -1)).rgb) * -1.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, 1)).rgb) * 1.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(0, 1)).rgb) * 2.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, 1)).rgb) * 1.0;

                            float edgeStrength = sqrt(gX * gX + gY * gY);
                            float dynamicEdgeThreshold = mix(0.3, 0.05, backgroundEdgeSensitivity);
                            dynamicEdgeThreshold = max(0.0, dynamicEdgeThreshold - audioVolume * 0.2); // Audio makes it more sensitive
                            
                            finalColor = vec3(0.0); // Start with black background for edges
                            if (edgeStrength > dynamicEdgeThreshold) {
                                finalColor = backgroundMaterialColor; // Apply material color to edges
                            }
                        } else if (isCameraActive) { // Apply other base filters for camera
                            if (backgroundFilterMode == 1) { // Grayscale
                                float gray = toGrayscale(finalColor);
                                finalColor = vec3(gray);
                            } else if (backgroundFilterMode == 2) { // Invert
                                finalColor = vec3(1.0 - finalColor.r, 1.0 - finalColor.g, 1.0 - finalColor.b);
                            } else if (backgroundFilterMode == 3) { // Sepia
                                finalColor = applySepia(finalColor);
                            } else if (backgroundFilterMode == 4) { // Pixelate
                                vec2 texelSize = 1.0 / vec2(textureSize(backgroundTexture, 0));
                                vec2 pixelatedUV = floor(vUv * backgroundPixelateSize) / backgroundPixelateSize;
                                finalColor = texture2D(backgroundTexture, pixelatedUV).rgb;
                            } else if (backgroundFilterMode == 5) { // Blur
                                vec2 texelSize = 1.0 / vec2(textureSize(backgroundTexture, 0));
                                vec3 blurredColor = vec3(0.0);
                                float count = 0.0;
                                for (float y = -backgroundBlurAmount; y <= backgroundBlurAmount; y += 1.0) {
                                    for (float x = -backgroundBlurAmount; x <= backgroundBlurAmount; x += 1.0) {
                                        blurredColor += texture2D(backgroundTexture, vUv + vec2(x, y) * texelSize).rgb;
                                        count += 1.0;
                                    }
                                }
                                finalColor = blurredColor / count;
                            }
                            // If backgroundFilterMode is 0 ('none'), no base filter is applied.
                        } else { // Apply NEW IMAGE EFFECTS only if camera is NOT active
                            if (uHueRotate != 0.0) {
                                vec3 hsv = rgbToHsv(finalColor);
                                hsv.x = fract(hsv.x + uHueRotate / (2.0 * 3.14159)); // Normalize angle to 0-1 range for HSV hue
                                finalColor = hsvToRgb(hsv);
                            }
                            if (uSaturation != 1.0) {
                                finalColor = adjustSaturation(finalColor, uSaturation);
                            }
                            if (uVignette > 0.0) {
                                finalColor = applyVignette(finalColor, uVignette);
                            }
                            if (uPosterizeLevels < 255.0) {
                                finalColor = applyPosterize(finalColor, uPosterizeLevels);
                            }
                            if (uSharpenAmount > 0.0) {
                                finalColor = applySharpen(backgroundTexture, vUv, uSharpenAmount);
                            }
                            if (uScanlineDensity > 0.0) {
                                finalColor = applyScanline(finalColor, uScanlineDensity);
                            }
                        }

                        // 4. Add Noise (always apply if noiseAmount > 0)
                        float n = noise(vUv * 100.0 + time * 0.5) * 2.0 - 1.0;
                        finalColor += n * backgroundNoiseAmount;

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.NormalBlending,
                depthWrite: false,
            }));
            imagePlane.position.z = -99; // Place it far back
            imagePlane.visible = false;
            scene.add(imagePlane);

            // Create the video element for camera feed (hidden)
            videoFeed = document.createElement('video');
            videoFeed.autoplay = true;
            videoFeed.playsInline = true;
            videoFeed.style.display = 'none'; // Keep it hidden
            // Append video element to body (it doesn't need to be in the canvas container)
            document.body.appendChild(videoFeed);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('fullscreenchange', onFullscreenChange);
        }

        function onWindowResize() {
            // Adjust main visualizer canvas
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Adjust the size of background meshes (imagePlane)
            if (imagePlane && imagePlane.visible && imagePlane.material.uniforms.backgroundTexture && imagePlane.material.uniforms.backgroundTexture.value) {
                const texture = imagePlane.material.uniforms.backgroundTexture.value;
                // For video textures, the image property might not be immediately available
                const textureAspect = (texture.image && texture.image.videoWidth) ? texture.image.videoWidth / texture.image.videoHeight : (texture.image ? texture.image.width / texture.image.height : 1);

                const viewHeight = 2 * Math.tan(camera.fov * Math.PI / 360) * Math.abs(imagePlane.position.z - camera.position.z);
                const viewWidth = viewHeight * camera.aspect;

                let scaleX, scaleY;

                // Scale to cover the view, then apply backgroundScaleFactor
                if (viewWidth / textureAspect >= viewHeight) {
                    scaleX = viewWidth * params.backgroundScaleFactor;
                    scaleY = (viewWidth / textureAspect) * params.backgroundScaleFactor;
                } else {
                    scaleX = (viewHeight * textureAspect) * params.backgroundScaleFactor;
                    scaleY = viewHeight * params.backgroundScaleFactor;
                }
                imagePlane.scale.set(scaleX, scaleY, 1);
            }

            // Adjust the size of the fractal noise plane to cover the screen
            if (currentVisualMode === 'fractalNoise' && visualObjects.length > 0 && visualObjects[0].mesh) {
                const plane = visualObjects[0].mesh;
                const viewHeight = 2 * Math.tan(camera.fov * Math.PI / 360) * Math.abs(camera.position.z - plane.position.z);
                const viewWidth = viewHeight * camera.aspect;
                plane.scale.set(viewWidth, viewHeight, 1);
            }
            // Adjust the size of Hydra planes to cover the screen
            if ((currentVisualMode === 'hydraFuego' || currentVisualMode === 'hydraGlitch' || currentVisualMode === 'hydraTunel') && visualObjects.length > 0 && visualObjects[0].mesh) {
                const plane = visualObjects[0].mesh;
                const viewHeight = 2 * Math.tan(camera.fov * Math.PI / 360) * Math.abs(camera.position.z - plane.position.z);
                const viewWidth = viewHeight * camera.aspect;
                plane.scale.set(viewWidth, viewHeight, 1);
            }
        }

        function onFullscreenChange() {
            // Get all relevant UI containers
            const allHeaders = document.querySelectorAll('.header-container');
            const allSidebars = [leftSidebarContainer, rightSidebarContainer]; // Include both sidebars
            const allFooters = [footerContainer]; // Only one footer
            const allProfileContents = document.querySelectorAll('.profile-page-content'); // Contents of profile pages

            if (document.fullscreenElement) {
                // If entering fullscreen, hide all UI elements
                allHeaders.forEach(el => el.classList.add('hidden'));
                allSidebars.forEach(el => el.classList.add('hidden')); // Hide sidebars
                allFooters.forEach(el => el.classList.add('hidden'));
                allProfileContents.forEach(el => el.style.display = 'none'); // Hide content of profile pages
                audioDebugInfo.style.display = 'none';
                showMessage('¡pantalla completa activada! presiona esc para salir.'); // Message to exit
            } else {
                // If exiting fullscreen, show UI elements based on the active page
                const currentPage = document.querySelector('.page:not(.hidden)');

                if (currentPage && currentPage.id === 'mainVisualizerPage') {
                    headerContainerMain.classList.remove('hidden');
                    leftSidebarContainer.classList.remove('hidden'); // Show left sidebar
                    rightSidebarContainer.classList.remove('hidden'); // Show right sidebar
                    footerContainer.classList.remove('hidden');
                    if (audioContext && audioContext.state === 'running') {
                        audioDebugInfo.style.display = 'block';
                    }
                } else if (currentPage && (currentPage.id === 'maroPage' || currentPage.id === 'jucaPage')) {
                    // For profile pages, show their specific header and content
                    const currentProfileHeader = currentPage.querySelector('.header-container');
                    const currentProfileContent = currentPage.querySelector('.profile-page-content');
                    if (currentProfileHeader) currentProfileHeader.classList.remove('hidden');
                    if (currentProfileContent) currentProfileContent.style.display = 'flex'; // Assuming display flex for content
                }
            }
            onWindowResize(); // Readjust canvas and camera size
        }

        // --- Functions for different visual modes ---
        function clearVisuals() {
            visualObjects.forEach(obj => {
                if (obj.mesh) {
                    if (obj.mesh.geometry) obj.mesh.geometry.dispose();
                    if (obj.mesh.material) {
                        if (Array.isArray(obj.mesh.material)) {
                            obj.mesh.material.forEach(m => m.dispose());
                        } else {
                            obj.mesh.material.dispose();
                        }
                    }
                    scene.remove(obj.mesh);
                }
                if (obj.wireframe) {
                    if (obj.wireframe.geometry) obj.wireframe.geometry.dispose();
                    if (obj.wireframe.material) {
                        if (Array.isArray(obj.wireframe.material)) {
                            obj.wireframe.material.forEach(m => m.dispose());
                        } else {
                            obj.wireframe.material.dispose();
                        }
                    }
                    scene.remove(obj.wireframe);
                }
                if (obj.points) {
                    if (obj.points.geometry) obj.points.geometry.dispose();
                    if (obj.points.material) {
                        if (Array.isArray(obj.points.material)) {
                            obj.points.material.forEach(m => m.dispose());
                        } else {
                            obj.points.material.dispose();
                        }
                    }
                    scene.remove(obj.points);
                }
            });
            visualObjects = [];
            if (particleBurstSystem) {
                scene.remove(particleBurstSystem);
                particleBurstSystem.geometry.dispose();
                particleBurstSystem.material.dispose();
                particleBurstSystem = null;
            }
        }

        function getCustomColor(index) {
            const hex = params.customColors[index % params.customColors.length];
            const color = new THREE.Color(hex);
            if (params.grayscale) {
                const gray = color.r * 0.299 + color.g * 0.587 + color.b * 0.114;
                color.setRGB(gray, gray, gray);
            }
            return color;
        }

        function applyMaterialColor(material, customColorIndex) {
            material.color.copy(getCustomColor(customColorIndex));
        }

        function createGeometricObject(geometry, index) {
            const solidMaterial = new THREE.MeshPhongMaterial({
                color: getCustomColor(index),
                transparent: true,
                opacity: params.layerOpacity,
            });
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: getCustomColor(index),
                wireframe: true,
                transparent: true,
                opacity: params.layerOpacity,
            });
            const pointsMaterial = new THREE.PointsMaterial({
                color: getCustomColor(index),
                size: 0.1,
                transparent: true,
                opacity: params.layerOpacity,
                blending: THREE.AdditiveBlending,
            });

            const mesh = new THREE.Mesh(geometry, solidMaterial);
            const wireframe = new THREE.Mesh(geometry, wireframeMaterial);
            const points = new THREE.Points(geometry, pointsMaterial);

            const deformableGeometry = geometry.clone();
            deformableGeometry.userData.originalPositions = Array.from(deformableGeometry.attributes.position.array);

            mesh.geometry = deformableGeometry;
            wireframe.geometry = deformableGeometry;
            points.geometry = deformableGeometry;

            const obj = { mesh, wireframe, points, index };
            scene.add(mesh);
            scene.add(wireframe);
            scene.add(points);

            updateMaterialMode(obj, params.materialMode);

            return obj;
        }

        function updateMaterialMode(obj, mode) {
            if (obj.mesh) obj.mesh.visible = (mode === 0);
            if (obj.wireframe) obj.wireframe.visible = (mode === 1);
            if (obj.points) obj.points.visible = (mode === 2);
        }

        function applyDeformation(obj, normalizedAmplitude, deformationLevel) {
            const geometry = obj.mesh.geometry;
            const positions = geometry.attributes.position.array;
            const originalPositions = geometry.userData.originalPositions;

            if (!originalPositions) return;

            for (let i = 0; i < positions.length; i += 3) {
                const originalX = originalPositions[i];
                const originalY = originalPositions[i + 1];
                const originalZ = originalPositions[i + 2];

                positions[i] = originalX * (1 + Math.sin(performance.now() * 0.005 + originalX * 0.1) * normalizedAmplitude * deformationLevel * 0.5);
                positions[i + 1] = originalY * (1 + Math.cos(performance.now() * 0.005 + originalY * 0.1) * normalizedAmplitude * deformationLevel * 0.5);
                positions[i + 2] = originalZ * (1 + Math.sin(performance.now() * 0.005 + originalZ * 0.1) * normalizedAmplitude * deformationLevel * 0.5);
            }
            geometry.attributes.position.needsUpdate = true;
        }

        // Mode 1: Pulsating Spheres
        function createSpheresVisual() {
            clearVisuals();
            const numSpheres = 20;
            for (let i = 0; i < numSpheres; i++) {
                const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 2: Reactive Particles
        function createParticlesVisual() {
            clearVisuals();
            const numParticles = 20000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(numParticles * 3);
            const originalPositions = new Float32Array(numParticles * 3);
            const colors = new Float32Array(numParticles * 3);

            for (let i = 0; i < numParticles; i++) {
                const x = (Math.random() - 0.5) * 20;
                const y = (Math.random() - 0.5) * 20;
                const z = (Math.random() - 0.5) * 20;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                originalPositions[i * 3] = x;
                originalPositions[i * 3 + 1] = y;
                originalPositions[i * 3 + 2] = z;

                const color = getCustomColor(i);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: params.layerOpacity,
                blending: THREE.AdditiveBlending,
            });

            const particles = new THREE.Points(geometry, material);
            particles.userData.originalPositions = originalPositions;
            scene.add(particles);
            visualObjects.push({ points: particles });
        }

        // Mode 3: Color Waves (using a subdivided plane)
        function createWavesVisual() {
            clearVisuals();
            const planeGeometry = new THREE.PlaneGeometry(15, 15, 80, 80);
            const obj = createGeometricObject(planeGeometry, 0);
            obj.mesh.rotation.x = -Math.PI / 2;
            obj.wireframe.rotation.x = -Math.PI / 2;
            obj.points.rotation.x = -Math.PI / 2;
            visualObjects.push(obj);
        }

        // Mode 4: Rotating Cubes
        function createCubesVisual() {
            clearVisuals();
            const numCubes = 15;
            for (let i = 0; i < numCubes; i++) {
                const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 5: Audio Bars (similar to an equalizer)
        function createAudioBarsVisual() {
            clearVisuals();
            const numBars = 64;
            const barWidth = 0.1;
            const barSpacing = 0.15;
            for (let i = 0; i < numBars; i++) {
                const geometry = new THREE.BoxGeometry(barWidth, 0.1, barWidth);
                const material = new THREE.MeshPhongMaterial({
                    color: getCustomColor(i),
                    transparent: true,
                    opacity: params.layerOpacity,
                });
                const bar = new THREE.Mesh(geometry, material);
                bar.position.x = (i - numBars / 2) * barSpacing;
                bar.position.y = -2;
                scene.add(bar);
                visualObjects.push({ mesh: bar });
            }
        }

        // Mode 6: Multiple Toruses
        function createTorusVisual() {
            clearVisuals();
            const numToruses = 8;
            for (let i = 0; i < numToruses; i++) {
                const geometry = new THREE.TorusGeometry(2, 0.8, 16, 100);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 7: Torus Knot (Single instance, as requested)
        function createTorusKnotVisual() {
            clearVisuals();
            const geometry = new THREE.TorusKnotGeometry(2.5, 0.8, 100, 16);
            const obj = createGeometricObject(geometry, 0);
            visualObjects.push(obj);
        }

        // Mode 8: Multiple Dodecahedrons
        function createDodecahedronVisual() {
            clearVisuals();
            const numDodecahedrons = 5;
            for (let i = 0; i < numDodecahedrons; i++) {
                const geometry = new THREE.DodecahedronGeometry(2);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 9: Multiple Icosahedrons
        function createIcosahedronVisual() {
            clearVisuals();
            const numIcosahedrons = 5;
            for (let i = 0; i < numIcosahedrons; i++) {
                const geometry = new THREE.IcosahedronGeometry(2);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 10: Multiple Octahedrons
        function createOctahedronVisual() {
            clearVisuals();
            const numOctahedrons = 5;
            for (let i = 0; i < numOctahedrons; i++) {
                const geometry = new THREE.OctahedronGeometry(2);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 11: Multiple Cones
        function createConeVisual() {
            clearVisuals();
            const numCones = 7;
            for (let i = 0; i < numCones; i++) {
                const geometry = new THREE.ConeGeometry(1.5, 3, 32);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 12: Multiple Cylinders
        function createCylinderVisual() {
            clearVisuals();
            const numCylinders = 7;
            for (let i = 0; i < numCylinders; i++) {
                const geometry = new THREE.CylinderGeometry(1, 1, 3, 32);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 13: Multiple Rings
        function createRingVisual() {
            clearVisuals();
            const numRings = 10;
            for (let i = 0; i < numRings; i++) {
                const geometry = new THREE.RingGeometry(1, 2, 32);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 14: Multiple Tetrahedrons
        function createTetrahedronVisual() {
            clearVisuals();
            const numTetrahedrons = 5;
            for (let i = 0; i < numTetrahedrons; i++) {
                const geometry = new THREE.TetrahedronGeometry(2);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 15: Multi-Toruses (already multiple)
        function createMultiTorusVisual() {
            clearVisuals();
            const numToruses = 8;
            for (let i = 0; i < numToruses; i++) {
                const geometry = new THREE.TorusGeometry(1.5, 0.5, 10, 50);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        // Mode 16: Ring Gyroscope
        function createGyroscope1Visual() {
            clearVisuals();
            const numRings = 5;
            for (let i = 0; i < numRings; i++) {
                const radius = 1 + i * 0.5;
                const geometry = new THREE.RingGeometry(radius - 0.1, radius + 0.1, 64);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.rotation.x = Math.PI / 2;
                obj.wireframe.rotation.x = Math.PI / 2;
                obj.points.rotation.x = Math.PI / 2;
                visualObjects.push(obj);
            }
        }

        // Mode 17: Nested Spheres Gyroscope
        function createGyroscope2Visual() {
            clearVisuals();
            const numSpheres = 4;
            for (let i = 0; i < numSpheres; i++) {
                const radius = 0.8 + i * 0.6;
                const geometry = new THREE.SphereGeometry(radius, 32, 32);
                const obj = createGeometricObject(geometry, i);
                visualObjects.push(obj);
            }
        }

        // Mode 18: Intersecting Toruses Gyroscope
        function createGyroscope3Visual() {
            clearVisuals();
            const numToruses = 3;
            for (let i = 0; i < numToruses; i++) {
                const geometry = new THREE.TorusGeometry(2.5, 0.5, 16, 100);
                const obj = createGeometricObject(geometry, i);
                if (i === 0) obj.mesh.rotation.x = Math.PI / 2;
                if (i === 1) obj.mesh.rotation.y = Math.PI / 2;
                if (i === 2) obj.mesh.rotation.z = Math.PI / 2;
                obj.wireframe.rotation.copy(obj.mesh.rotation);
                obj.points.rotation.copy(obj.mesh.rotation);
                visualObjects.push(obj);
            }
        }

        // NEW Mode 19: Fractal Noise (Full-screen shader-based)
        const fractalNoiseVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fractalNoiseFragmentShader = `
            uniform float time;
            uniform float audioAmplitude;
            uniform float colorSpeed;
            uniform float deformationLevel;
            uniform float shapeScale;
            uniform vec3 customColor1;
            uniform vec3 customColor2;
            uniform vec3 customColor3;
            uniform bool grayscale;
            uniform float layerOpacity;

            varying vec2 vUv;

            // Hash function for random values
            float hash(float n) { return fract(sin(n) * 43758.5453123); }

            // 2D Noise (simplified Perlin-like)
            float noise2D(vec2 p) {
                vec2 ip = floor(p);
                vec2 fp = fract(p);
                fp = fp * fp * (3.0 - 2.0 * fp);
                float tl = hash(ip.x + ip.y * 57.0);
                float tr = hash(ip.x + 1.0 + ip.y * 57.0);
                float bl = hash(ip.x + (ip.y + 1.0) * 57.0);
                float br = hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0);
                return mix(mix(tl, tr, fp.x), mix(bl, br, fp.x), fp.y);
            }

            // Fractal Brownian Motion (FBM)
            float fbm(vec2 p) {
                float sum = 0.0;
                float amp = 0.5;
                float freq = 1.0;
                for (int i = 0; i < 5; i++) {
                    sum += noise2D(p * freq) * amp;
                    freq *= 2.0;
                    amp *= 0.5;
                }
                return sum;
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0; // Normalize UV to -1 to 1
                uv *= shapeScale; // Apply global scale
                uv += vec2(sin(time * 0.1), cos(time * 0.08)) * 0.5 * deformationLevel; // Subtle movement

                float f = fbm(uv + time * colorSpeed * 0.5); // Base fractal noise
                f += fbm(uv * 2.0 + time * colorSpeed * 0.7) * 0.5; // Add more detail
                f += audioAmplitude * 0.5; // Audio reactivity

                vec3 color = mix(customColor1, customColor2, f);
                color = mix(color, customColor3, f * 0.5 + 0.5);

                if (grayscale) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    color = vec3(gray);
                }

                gl_FragColor = vec4(color, layerOpacity);
            }
        `;

        function createFractalNoiseVisual() {
            clearVisuals();
            const planeGeometry = new THREE.PlaneGeometry(2, 2); // A plane that covers the whole screen
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    audioAmplitude: { value: 0.0 },
                    colorSpeed: { value: params.colorSpeed },
                    deformationLevel: { value: params.deformationLevel },
                    shapeScale: { value: params.shapeScale },
                    customColor1: { value: new THREE.Color(params.customColors[0]) },
                    customColor2: { value: new THREE.Color(params.customColors[1]) },
                    customColor3: { value: new THREE.Color(params.customColors[2]) },
                    grayscale: { value: params.grayscale },
                    layerOpacity: { value: params.layerOpacity },
                },
                vertexShader: fractalNoiseVertexShader,
                fragmentShader: fractalNoiseFragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending, // Use additive blending for a glowing effect
            });
            const mesh = new THREE.Mesh(planeGeometry, material);
            mesh.position.z = -1; // Place it slightly behind other objects if any
            scene.add(mesh);
            visualObjects.push({ mesh: mesh, update: (delta, audioAmplitude) => {
                material.uniforms.time.value += delta;
                material.uniforms.audioAmplitude.value = audioAmplitude;
                material.uniforms.colorSpeed.value = params.colorSpeed;
                material.uniforms.deformationLevel.value = params.deformationLevel;
                material.uniforms.shapeScale.value = params.shapeScale;
                material.uniforms.customColor1.value.set(params.customColors[0]);
                material.uniforms.customColor2.value.set(params.customColors[1]);
                material.uniforms.customColor3.value.set(params.customColors[2]);
                material.uniforms.grayscale.value = params.grayscale;
                material.uniforms.layerOpacity.value = params.layerOpacity;
            }});
            onWindowResize(); // Adjust size to fill screen
        }

        // NEW HYDRA SHADERS
        const vertexShaderHydra = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShaderHydraFuego = `
            uniform float time;
            uniform float audioAmplitude; // New uniform for audio reactivity
            uniform float shapeScale; // New uniform for global scale
            uniform float colorSpeed; // New uniform for color speed
            varying vec2 vUv;

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                uv /= shapeScale; // Apply global scale to UVs

                float r = length(uv);
                float angle = atan(uv.y, uv.x);

                // Audio reactivity: make swirl more intense with audio
                float swirl = sin(r * 10.0 - time * 2.0 * colorSpeed + audioAmplitude * 5.0);
                float radial = cos(angle * 3.0 + time * colorSpeed) * 0.5 + 0.5;
                float flare = pow(1.0 - r, 3.0);

                vec3 color = vec3(
                    sin(time * colorSpeed + uv.x * 3.0) * 0.5 + 0.5,
                    cos(time * colorSpeed + uv.y * 3.0) * 0.5 + 0.5,
                    swirl * radial
                );

                // Audio reactivity: make flare brighter with audio
                color *= flare * (3.0 + audioAmplitude * 2.0);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // NEW HYDRA GLITCH SHADER
        const fragmentShaderHydraGlitch = `
            uniform float time;
            uniform float audioAmplitude;
            uniform float shapeScale;
            uniform float colorSpeed;
            uniform float deformationLevel;
            varying vec2 vUv;

            // Hash function for random values
            float hash(float n) { return fract(sin(n) * 43758.5453123); }

            // 2D Noise (simplified Perlin-like)
            float noise2D(vec2 p) {
                vec2 ip = floor(p);
                vec2 fp = fract(p);
                fp = fp * fp * (3.0 - 2.0 * fp);
                float tl = hash(ip.x + ip.y * 57.0);
                float tr = hash(ip.x + 1.0 + ip.y * 57.0);
                float bl = hash(ip.x + (ip.y + 1.0) * 57.0);
                float br = hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0);
                return mix(mix(tl, tr, fp.x), mix(bl, br, fp.x), fp.y);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                uv /= shapeScale; // Apply global scale

                // Glitch effect based on time and audio
                vec2 glitchOffset = vec2(
                    sin(time * 10.0 + uv.y * 50.0) * 0.05 * audioAmplitude * deformationLevel,
                    cos(time * 12.0 + uv.x * 50.0) * 0.05 * audioAmplitude * deformationLevel
                );
                uv += glitchOffset;

                // Tiling/fragmentation
                vec2 tiledUV = fract(uv * (5.0 + audioAmplitude * 2.0)); // More tiles with audio
                float n = noise2D(uv * 10.0 + time * colorSpeed); // Noise for distortion

                vec3 color = vec3(
                    sin(time * colorSpeed + tiledUV.x * 10.0 + n) * 0.5 + 0.5,
                    cos(time * colorSpeed + tiledUV.y * 10.0 + n) * 0.5 + 0.5,
                    sin(time * colorSpeed * 0.7 + tiledUV.x * 5.0 + tiledUV.y * 5.0 + n) * 0.5 + 0.5
                );

                // Add some sharp edges/fragments
                float fragmentEffect = step(0.5, fract(uv.x * 10.0 + uv.y * 10.0 + time));
                color = mix(color, vec3(1.0 - color), fragmentEffect * audioAmplitude); // Invert colors on fragments

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // NEW HYDRA TUNNEL SHADER
        const fragmentShaderHydraTunel = `
            uniform float time;
            uniform float audioAmplitude;
            uniform float shapeScale;
            uniform float colorSpeed;
            uniform float deformationLevel;
            varying vec2 vUv;

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                uv /= shapeScale; // Apply global scale

                // Convert to polar coordinates
                float r = length(uv);
                float angle = atan(uv.y, uv.x);

                // Create a pulsating tunnel effect
                float tunnelSpeed = time * colorSpeed * 5.0;
                float tunnelDistortion = sin(r * 15.0 - tunnelSpeed + audioAmplitude * 10.0) * 0.1 * deformationLevel;
                r += tunnelDistortion;

                // Create stripes or rings
                float stripes = fract(r * 5.0 - tunnelSpeed * 0.5);
                stripes = pow(stripes, 2.0); // Sharpen the stripes

                // Color based on angle and stripes
                vec3 color = vec3(
                    sin(angle * 5.0 + time * colorSpeed) * 0.5 + 0.5,
                    cos(angle * 3.0 + time * colorSpeed * 0.7) * 0.5 + 0.5,
                    sin(angle * 7.0 + time * colorSpeed * 1.2) * 0.5 + 0.5
                );

                // Mix with stripes
                color = mix(color, vec3(stripes), 0.7); // Blend with stripes

                // Add a central glow
                float glow = pow(1.0 - r, 5.0 + audioAmplitude * 5.0); // Brighter glow with audio
                color += vec3(glow);

                gl_FragColor = vec4(color, 1.0);
            }
        `;


        // NEW HYDRA VISUAL FUNCTION
        function createHydraFuegoVisual() {
            clearVisuals();

            const geometry = new THREE.PlaneGeometry(2, 2);
            const uniforms = {
                time: { value: 0 },
                audioAmplitude: { value: 0.0 }, // Initialize audioAmplitude uniform
                shapeScale: { value: params.shapeScale }, // Pass global scale
                colorSpeed: { value: params.colorSpeed } // Pass color speed
            };

            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShaderHydra,
                fragmentShader: fragmentShaderHydraFuego,
                uniforms: uniforms,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending, // Hydra often uses additive blending
                transparent: true
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -1; // Place it slightly behind other objects if any
            scene.add(mesh);
            visualObjects.push({ mesh: mesh, update: (delta, audioAmplitude) => {
                material.uniforms.time.value += delta;
                material.uniforms.audioAmplitude.value = audioAmplitude;
                material.uniforms.shapeScale.value = params.shapeScale; // Update scale
                material.uniforms.colorSpeed.value = params.colorSpeed; // Update color speed
            }});
            onWindowResize(); // Adjust size to fill screen
        }

        function createHydraGlitchVisual() {
            clearVisuals();
            const geometry = new THREE.PlaneGeometry(2, 2);
            const uniforms = {
                time: { value: 0 },
                audioAmplitude: { value: 0.0 },
                shapeScale: { value: params.shapeScale },
                colorSpeed: { value: params.colorSpeed },
                deformationLevel: { value: params.deformationLevel }
            };
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShaderHydra,
                fragmentShader: fragmentShaderHydraGlitch,
                uniforms: uniforms,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -1;
            scene.add(mesh);
            visualObjects.push({ mesh: mesh, update: (delta, audioAmplitude) => {
                material.uniforms.time.value += delta;
                material.uniforms.audioAmplitude.value = audioAmplitude;
                material.uniforms.shapeScale.value = params.shapeScale;
                material.uniforms.colorSpeed.value = params.colorSpeed;
                material.uniforms.deformationLevel.value = params.deformationLevel;
            }});
            onWindowResize();
        }

        function createHydraTunelVisual() {
            clearVisuals();
            const geometry = new THREE.PlaneGeometry(2, 2);
            const uniforms = {
                time: { value: 0 },
                audioAmplitude: { value: 0.0 },
                shapeScale: { value: params.shapeScale },
                colorSpeed: { value: params.colorSpeed },
                deformationLevel: { value: params.deformationLevel }
            };
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShaderHydra,
                fragmentShader: fragmentShaderHydraTunel,
                uniforms: uniforms,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -1;
            scene.add(mesh);
            visualObjects.push({ mesh: mesh, update: (delta, audioAmplitude) => {
                material.uniforms.time.value += delta;
                material.uniforms.audioAmplitude.value = audioAmplitude;
                material.uniforms.shapeScale.value = params.shapeScale;
                material.uniforms.colorSpeed.value = params.colorSpeed;
                material.uniforms.deformationLevel.value = params.deformationLevel;
            }});
            onWindowResize();
        }


        // Changes the visual mode
        function switchVisualMode(mode) {
            clearVisuals();
            currentVisualMode = mode;
            switch (mode) {
                case 'spheres': createSpheresVisual(); break;
                case 'particles': createParticlesVisual(); break;
                case 'waves': createWavesVisual(); break;
                case 'cubes': createCubesVisual(); break;
                case 'audioBars': createAudioBarsVisual(); break;
                case 'torus': createTorusVisual(); break;
                case 'torusKnot': createTorusKnotVisual(); break;
                case 'dodecahedron': createDodecahedronVisual(); break;
                case 'icosahedron': createIcosahedronVisual(); break;
                case 'octahedron': createOctahedronVisual(); break;
                case 'cone': createConeVisual(); break;
                case 'cylinder': createCylinderVisual(); break;
                case 'ring': createRingVisual(); break;
                case 'tetrahedron': createTetrahedronVisual(); break;
                case 'multiTorus': createMultiTorusVisual(); break;
                case 'gyroscope1': createGyroscope1Visual(); break;
                case 'gyroscope2': createGyroscope2Visual(); break;
                case 'gyroscope3': createGyroscope3Visual(); break;
                case 'fractalNoise': createFractalNoiseVisual(); break;
                case 'hydraFuego': createHydraFuegoVisual(); break;
                case 'hydraGlitch': createHydraGlitchVisual(); break; // NEW HYDRA CASE
                case 'hydraTunel': createHydraTunelVisual(); break; // NEW HYDRA CASE
            }
            visualObjects.forEach(obj => {
                if (obj.mesh && obj.wireframe && obj.points) {
                    updateMaterialMode(obj, params.materialMode);
                }
            });
        }

        function createParticleBurst(position, color, scale = 1.0) {
            const burstGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const burstMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending
            });
            const burstParticle = new THREE.Mesh(burstGeometry, burstMaterial);
            burstParticle.position.copy(position);
            burstParticle.scale.set(scale, scale, scale);
            scene.add(burstParticle);

            let opacity = 1.0;
            let currentScale = scale;
            const animateBurst = () => {
                if (opacity > 0) {
                    opacity -= 0.05;
                    currentScale += 0.05;
                    burstParticle.material.opacity = opacity;
                    burstParticle.scale.set(currentScale, currentScale, currentScale);
                    requestAnimationFrame(animateBurst);
                } else {
                    burstParticle.geometry.dispose();
                    burstParticle.material.dispose();
                    scene.remove(burstParticle);
                }
            };
            animateBurst();
        }

        /**
         * Clears all background planes (image or camera) to ensure only one is active.
         */
        function clearAllBackgroundPlanes() {
            stopImageCarousel(); // Stop any ongoing image carousel
            loadedImageTextures.forEach(tex => tex.dispose());
            loadedImageTextures = [];
            currentImageIndex = -1;

            stopCameraAsBackground(); // Stop camera if it's active

            if (imagePlane) { // Check if imagePlane exists before accessing its properties
                if (imagePlane.material.uniforms.backgroundTexture.value) {
                    imagePlane.material.uniforms.backgroundTexture.value.dispose();
                }
                imagePlane.material.uniforms.backgroundTexture.value = null;
                imagePlane.visible = false;
            }
        }


        async function setupAudio(deviceId = null) {
            if (audioContext) {
                // If audio context exists, try to close it first to reset
                if (audioContext.state !== 'closed') {
                    await audioContext.close();
                }
            }
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256; // More detail for frequency bands
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);

                const constraints = { audio: { deviceId: deviceId ? { exact: deviceId } : undefined } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                toggleAudioBtn.textContent = 'desactivar audio';
                audioDebugInfo.style.display = 'block'; // Show debug info
                showMessage('¡audio activado! el micrófono está escuchando la onda.');

            } catch (err) {
                console.error('error al acceder al micrófono:', err);
                let userMessage = '¡ay, carnal! no pude acceder al micrófono. ';
                if (err.name === 'NotAllowedError') {
                    userMessage += 'parece que los permisos fueron denegados por tu navegador. por favor, revisa la configuración de tu navegador para permitir el acceso al micrófono.';
                } else if (err.name === 'NotFoundError') {
                    userMessage += 'no se encontró ningún micrófono. asegúrate de que uno esté conectado y funcionando.';
                } else if (err.message && err.message.includes('Permission denied by system')) {
                    userMessage += '¡permiso denegado por el sistema! para activar el audio, necesitas ir a la configuración de privacidad y seguridad de tu sistema operativo y navegador para permitir el acceso al micrófono.';
                } else {
                    userMessage += `error: ${err.message}. checa los permisos de tu navegador.`;
                }
                showMessage(userMessage);
                toggleAudioBtn.textContent = 'activar audio';
                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close();
                }
                audioContext = null;
                analyser = null;
                microphone = null;
                dataArray = null;
            }
        }

        function stopAudio() {
            if (audioContext) {
                if (microphone && microphone.mediaStream) {
                    microphone.mediaStream.getTracks().forEach(track => track.stop()); // Explicitly stop tracks
                }
                audioContext.close();
                audioContext = null;
                analyser = null;
                microphone = null;
                dataArray = null;
                toggleAudioBtn.textContent = 'activar audio';
                audioDebugInfo.style.display = 'none'; // Hide debug info
                // showMessage('audio desactivado. ¡silencio total!'); // Removed to prevent message on page change
            }
        }

        // --- Load Background Image ---
        function loadImageAsBackground(event) {
            const files = event.target.files;
            if (files.length > 0) {
                clearAllBackgroundPlanes(); // Clear other backgrounds before activating image

                // Clear existing image textures
                loadedImageTextures.forEach(tex => tex.dispose());
                loadedImageTextures = [];
                currentImageIndex = -1;
                stopImageCarousel();

                const textureLoader = new THREE.TextureLoader();
                let loadedCount = 0;

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        textureLoader.load(e.target.result, function(texture) {
                            console.log('background image texture loaded successfully:', texture); // Debugging
                            loadedImageTextures.push(texture);
                            loadedCount++;

                            if (loadedCount === files.length) {
                                showMessage(`¡${loadedCount} imagen(es) de fondo cargada(s) con éxito!`);
                                currentImageIndex = 0;
                                updateImagePlaneTexture(loadedImageTextures[currentImageIndex], false); // Not a camera
                                if (loadedImageTextures.length > 1) {
                                    startImageCarousel();
                                }
                            }
                        }, undefined, function(err) {
                            console.error('error loading texture:', err); // Debugging
                            showMessage('¡ups! hubo un error al cargar una imagen. intenta con otra.');
                        });
                    };
                    reader.readAsDataURL(file);
                }
            } else {
                console.log('no image file selected.'); // Debugging
            }
        }

        function updateImagePlaneTexture(texture, isCameraSource) {
            if (imagePlane) {
                if (imagePlane.material.uniforms.backgroundTexture.value && imagePlane.material.uniforms.backgroundTexture.value !== texture) {
                    // Only dispose if it's a different texture
                    imagePlane.material.uniforms.backgroundTexture.value.dispose();
                }
                imagePlane.material.uniforms.backgroundTexture.value = texture;
                imagePlane.material.uniforms.isCameraActive.value = isCameraSource;
                isCameraActive = isCameraSource; // Update global flag
                imagePlane.visible = true;
                onWindowResize(); // Readjust image size to fill screen
            }
        }

        function startImageCarousel() {
            stopImageCarousel(); // Ensure no multiple intervals are running
            if (loadedImageTextures.length > 1) {
                imageChangeInterval = setInterval(() => {
                    currentImageIndex = (currentImageIndex + 1) % loadedImageTextures.length;
                    updateImagePlaneTexture(loadedImageTextures[currentImageIndex], false);
                }, IMAGE_CHANGE_INTERVAL_MS);
            }
        }

        function stopImageCarousel() {
            if (imageChangeInterval) {
                clearInterval(imageChangeInterval);
                imageChangeInterval = null;
            }
        }

        function clearBackgroundImage() {
            stopImageCarousel();
            loadedImageTextures.forEach(tex => tex.dispose());
            loadedImageTextures = [];
            currentImageIndex = -1;

            stopCameraAsBackground(); // Ensure camera is also stopped

            if (imagePlane) {
                if (imagePlane.material.uniforms.backgroundTexture.value) {
                    imagePlane.material.uniforms.backgroundTexture.value.dispose();
                }
                imagePlane.material.uniforms.backgroundTexture.value = null;
                imagePlane.visible = false;
            }
            showMessage('imagen de fondo borrada. ¡campo libre!');
        }

        // --- Camera as Background Functions ---
        async function startCameraAsBackground(deviceId) {
            if (currentCameraStream) {
                currentCameraStream.getTracks().forEach(track => track.stop());
                currentCameraStream = null;
            }

            try {
                const constraints = {
                    video: { deviceId: deviceId ? { exact: deviceId } : undefined },
                    // Do not request audio here, main audio context handles it
                };
                currentCameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoFeed.srcObject = currentCameraStream;

                videoFeed.onloadedmetadata = () => {
                    videoFeed.play().catch(e => console.error("Error playing video:", e)); // Ensure video plays
                    videoTexture = new THREE.VideoTexture(videoFeed);
                    videoTexture.minFilter = THREE.LinearFilter;
                    videoTexture.magFilter = THREE.LinearFilter;
                    videoTexture.format = THREE.RGBAFormat;
                    updateImagePlaneTexture(videoTexture, true); // Set as camera texture
                };
                showMessage('¡cámara activada como fondo!');
                startCameraBtn.disabled = true;
                stopCameraBtn.disabled = false;
            } catch (err) {
                console.error('error al iniciar la cámara:', err);
                let message = '¡falló la cámara! ';
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    message += 'necesitas darle permiso a la cámara en tu navegador.';
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    message += 'no se encontró la cámara. asegúrate de que esté conectada.';
                } else {
                    message += `error: ${err.name} - ${err.message}`;
                }
                showMessage(message);
                cameraSelect.value = ""; // Reset camera select
                stopCameraAsBackground(); // Ensure state is reset
            }
        }

        function stopCameraAsBackground() {
            if (currentCameraStream) {
                currentCameraStream.getTracks().forEach(track => track.stop());
                currentCameraStream = null;
                videoFeed.srcObject = null;
                if (videoTexture) {
                    videoTexture.dispose();
                    videoTexture = null;
                }
                if (imagePlane && imagePlane.material.uniforms.backgroundTexture.value) {
                    // Only clear the texture if it's the video texture
                    if (imagePlane.material.uniforms.backgroundTexture.value === videoTexture) {
                        imagePlane.material.uniforms.backgroundTexture.value = null;
                    }
                    imagePlane.material.uniforms.isCameraActive.value = false;
                    isCameraActive = false;
                    imagePlane.visible = false; // Hide the plane if no other background is active
                }
                showMessage('cámara de fondo detenida.');
            }
            startCameraBtn.disabled = false;
            stopCameraBtn.disabled = true;
        }


        // --- Main Visualizer Animation Loop ---
        let lastTime = 0;
        function animateMainVisualizer(time) {
            const delta = (time - lastTime) * 0.001; // Convert to seconds
            lastTime = time;

            let averageAmplitude = 0;
            let normalizedReaction = 0;
            let bassAmplitude = 0;
            let midAmplitude = 0;
            let trebleAmplitude = 0;

            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray);
                averageAmplitude = dataArray.reduce((sum, val) => sum + val, 0) / dataArray.length;

                // Divide into frequency bands
                const bufferLength = analyser.frequencyBinCount;
                const bassRange = Math.floor(bufferLength * 0.2); // 0-20% for bass
                const midRange = Math.floor(bufferLength * 0.5);  // 20-70% for mids
                // The rest for trebles

                for (let i = 0; i < bufferLength; i++) {
                    if (i < bassRange) {
                        bassAmplitude += dataArray[i];
                    } else if (i < midRange) {
                        midAmplitude += dataArray[i];
                    } else {
                        trebleAmplitude += dataArray[i];
                    }
                }
                bassAmplitude /= bassRange;
                midAmplitude /= (midRange - bassRange);
                trebleAmplitude /= (bufferLength - midRange);

                // Normalize band amplitudes (0-1) and apply threshold
                const normalizeBand = (amplitude, sensitivity) => {
                    if (amplitude > params.audioReactionThreshold) {
                        let normalized = (amplitude - params.audioReactionThreshold) / (255 - params.audioReactionThreshold);
                        return Math.max(0, Math.min(1, normalized)) * sensitivity;
                    }
                    return 0;
                };

                const normalizedBass = normalizeBand(bassAmplitude, params.bassSensitivity);
                const normalizedMid = normalizeBand(midAmplitude, params.midSensitivity);
                const normalizedTreble = normalizeBand(trebleAmplitude, params.trebleSensitivity);

                normalizedReaction = normalizeBand(averageAmplitude, params.amplitudeSensitivity);

                // Update audio debug info
                currentAmplitudeSpan.textContent = averageAmplitude.toFixed(0);
                normalizedReactionSpan.textContent = normalizedReaction.toFixed(2);
                bassAmplitudeSpan.textContent = normalizedBass.toFixed(2);
                midAmplitudeSpan.textContent = normalizedMid.toFixed(2);
                trebleAmplitudeSpan.textContent = trebleAmplitude.toFixed(2); // Keep this for raw treble if needed


                switch (currentVisualMode) {
                    case 'spheres':
                    case 'waves':
                    case 'cubes':
                    case 'torus':
                    case 'torusKnot':
                    case 'dodecahedron':
                    case 'icosahedron':
                    case 'octahedron':
                    case 'cone':
                    case 'cylinder':
                    case 'ring':
                    case 'tetrahedron':
                    case 'multiTorus':
                    case 'gyroscope1':
                    case 'gyroscope2':
                    case 'gyroscope3':
                        visualObjects.forEach((obj) => {
                            if (obj.mesh) {
                                obj.mesh.rotation.x += 0.005 + normalizedReaction * 0.01;
                                obj.mesh.rotation.y += 0.005 + normalizedReaction * 0.01;
                                obj.mesh.rotation.z += 0.005 + normalizedReaction * 0.01;

                                if (obj.wireframe) obj.wireframe.rotation.copy(obj.mesh.rotation);
                                if (obj.points) obj.points.rotation.copy(obj.mesh.rotation);

                                // Bass modifies size
                                const scale = params.shapeScale * (1 + normalizedBass * 0.8); // Affected by bass
                                obj.mesh.scale.set(scale, scale, scale);
                                if (obj.wireframe) obj.wireframe.scale.copy(obj.mesh.scale);
                                if (obj.points) obj.points.scale.copy(obj.mesh.scale);

                                // Treble modifies deformation (texture)
                                if (currentVisualMode !== 'torusKnot' && currentVisualMode !== 'audioBars' && obj.mesh.geometry.userData.originalPositions) {
                                    applyDeformation(obj, normalizedTreble, params.deformationLevel); // Affected by treble
                                }

                                obj.mesh.material.opacity = params.layerOpacity;
                                // Mids modify colors
                                const colorIndex = obj.index + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5); // Affected by mids
                                applyMaterialColor(obj.mesh.material, colorIndex);
                            }

                            if (obj.wireframe) {
                                obj.wireframe.material.opacity = params.layerOpacity;
                                const colorIndex = obj.index + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                applyMaterialColor(obj.wireframe.material, colorIndex);
                            }
                            if (obj.points) {
                                obj.points.material.opacity = params.layerOpacity;
                                const colorIndex = obj.index + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                applyMaterialColor(obj.points.material, colorIndex);
                                // Treble also modifies point size
                                obj.points.material.size = 0.1 + normalizedTreble * params.amplitudeSensitivity * 0.5;
                            }
                        });
                        break;
                    case 'particles':
                        const particles = visualObjects[0].points;
                        if (particles) {
                            const positions = particles.geometry.attributes.position.array;
                            const colors = particles.geometry.attributes.color.array;
                            const originalPositions = particles.userData.originalPositions;
                            const colorTemp = new THREE.Color();

                            for (let i = 0; i < particles.geometry.attributes.position.count; i++) {
                                // Bass modifies particle movement amplitude
                                positions[i * 3 + 1] = originalPositions[i * 3 + 1] +
                                                        (Math.sin(performance.now() * 0.002 + i / 100) * normalizedBass * 5) * params.shapeScale * params.deformationLevel;

                                // Mids modify colors
                                const colorIndex = i + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                colorTemp.copy(getCustomColor(colorIndex));
                                colors[i * 3] = colorTemp.r;
                                colors[i * 3 + 1] = colorTemp.g;
                                colors[i * 3 + 2] = colorTemp.b;
                            }
                            particles.geometry.attributes.position.needsUpdate = true;
                            particles.geometry.attributes.color.needsUpdate = true;
                            particles.material.opacity = params.layerOpacity;
                            // Treble modifies particle size
                            particles.material.size = 0.1 + normalizedTreble * params.amplitudeSensitivity * 0.5;
                        }
                        break;
                    case 'audioBars':
                        if (dataArray && visualObjects.length > 0) {
                            const numBars = visualObjects.length;
                            for (let i = 0; i < numBars; i++) {
                                const bar = visualObjects[i].mesh;
                                // Bass modifies base height, Treble modifies reaction
                                const barHeight = (dataArray[i] / 255 * 5 * params.amplitudeSensitivity * params.shapeScale) * (1 + normalizedBass * 0.5) + normalizedTreble * 2;
                                bar.scale.y = barHeight;
                                bar.position.y = -2 + barHeight / 2;
                                // Mids modify colors
                                const colorIndex = i + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                applyMaterialColor(bar.material, colorIndex);
                                bar.material.opacity = params.layerOpacity;
                            }
                        }
                        break;
                    case 'fractalNoise': // Update uniforms for Fractal Noise shader
                    case 'hydraFuego':
                    case 'hydraGlitch':
                    case 'hydraTunel':
                        const shaderMesh = visualObjects[0];
                        if (shaderMesh && shaderMesh.update) {
                            shaderMesh.update(delta, normalizedReaction); // Pass delta and audio amplitude
                        }
                        break;
                }

                if (normalizedReaction > 0.9 && visualObjects.length > 0) { // Use normalizedReaction for the burst
                    const burstColor = getCustomColor(Math.floor(Math.random() * params.customColors.length));
                    createParticleBurst(new THREE.Vector3(0, 0, 0), burstColor, normalizedReaction * 2);
                }
            }

            // Update background textures and uniforms
            if (imagePlane && imagePlane.visible && imagePlane.material.uniforms.backgroundTexture.value) {
                // If camera is active, use camera params. Otherwise, general image params.
                imagePlane.material.uniforms.isCameraActive.value = isCameraActive;
                imagePlane.material.uniforms.chromaKeyColor.value.set(params.chromaKeyColor);
                imagePlane.material.uniforms.chromaKeyThreshold.value = params.chromaKeyThreshold;

                // Apply camera specific filter params if camera is active, otherwise default to none for images
                imagePlane.material.uniforms.backgroundFilterMode.value = isCameraActive ? params.cameraFilterMode : 0; // Only camera has filters
                imagePlane.material.uniforms.backgroundNoiseAmount.value = isCameraActive ? params.cameraNoiseAmount : 0;
                imagePlane.material.uniforms.backgroundEdgeSensitivity.value = isCameraActive ? params.cameraEdgeSensitivity : 0;
                imagePlane.material.uniforms.backgroundBrightness.value = isCameraActive ? params.cameraBrightness : 0;
                imagePlane.material.uniforms.backgroundContrast.value = isCameraActive ? params.cameraContrast : 1;
                imagePlane.material.uniforms.backgroundPixelateSize.value = isCameraActive ? params.cameraPixelateSize : 1;
                imagePlane.material.uniforms.backgroundBlurAmount.value = isCameraActive ? params.cameraBlurAmount : 0;
                imagePlane.material.uniforms.backgroundMaterialColor.value.copy(isCameraActive ? params.cameraMaterialColor : backgroundMaterialColors.none);

                // NEW IMAGE EFFECT UNIFORM UPDATES
                imagePlane.material.uniforms.uHueRotate.value = params.hueRotate * Math.PI / 180.0;
                imagePlane.material.uniforms.uSaturation.value = params.saturation / 100.0;
                imagePlane.material.uniforms.uVignette.value = params.vignette / 100.0;
                imagePlane.material.uniforms.uPosterizeLevels.value = params.posterize;
                imagePlane.material.uniforms.uSharpenAmount.value = params.sharpen;
                imagePlane.material.uniforms.uScanlineDensity.value = params.scanline / 100.0;


                imagePlane.material.uniforms.audioVolume.value = normalizedReaction; // Use main audio for camera effects
                imagePlane.material.uniforms.time.value = performance.now() * 0.001;
            }

            renderer.render(scene, camera);
        }

        // --- MIDI Functions ---
        async function initMidi() {
            if (!navigator.requestMIDIAccess) {
                showMessage('¡híjole! tu navegador no soporta la api web midi o está deshabilitada por la política de permisos de tu navegador o sistema. no podrás usar controles midi.');
                // Disable MIDI related UI
                midiInputSelect.disabled = true;
                midiOutputSelect.disabled = true;
                midiChannelInput.disabled = true;
                startMidiLearnBtn.disabled = true;
                stopMidiLearnBtn.disabled = true;
                clearMidiMappingsBtn.disabled = true;
                midiMonitor.textContent = 'la api web midi no está disponible o está bloqueada.';
                return;
            }

            try {
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                midiAccess.onstatechange = onMidiStateChange;
                updateMidiDevices();
            } catch (err) {
                console.error('error al acceder a midi:', err);
                showMessage('¡ay, carnal! no pude acceder a midi. esto suele pasar si los permisos están denegados por tu navegador o sistema operativo. revisa la configuración de permisos de midi.');
                // Disable MIDI related UI on permission error
                midiInputSelect.disabled = true;
                midiOutputSelect.disabled = true;
                midiChannelInput.disabled = true;
                startMidiLearnBtn.disabled = true;
                stopMidiLearnBtn.disabled = true;
                clearMidiMappingsBtn.disabled = true;
                midiMonitor.textContent = 'acceso a midi denegado. revisa los permisos.';
            }
        }

        function onMidiStateChange(event) {
            console.log(`midi device state change: ${event.port.name} ${event.port.state}`);
            updateMidiDevices();
        }

        function updateMidiDevices() {
            midiInputs = midiAccess.inputs;
            midiOutputs = midiAccess.outputs;

            midiInputSelect.innerHTML = '<option value="">-- selecciona entrada --</option>';
            midiInputs.forEach(input => {
                const option = document.createElement('option');
                option.value = input.id;
                option.textContent = input.name;
                midiInputSelect.appendChild(option);
            });

            midiOutputSelect.innerHTML = '<option value="">-- selecciona salida --</option>';
            midiOutputs.forEach(output => {
                const option = document.createElement('option');
                option.value = output.id;
                option.textContent = output.name;
                midiOutputSelect.appendChild(option);
            });

            // Re-select previously selected input if it still exists
            if (selectedMidiInput && midiInputs.has(selectedMidiInput.id)) {
                midiInputSelect.value = selectedMidiInput.id;
            } else {
                selectedMidiInput = null;
            }
        }

        function onMidiMessage(event) {
            const data = event.data; // [status, data1, data2]
            const status = data[0];
            const type = status & 0xF0; // Message type (e.g., Note On, CC)
            const channel = (status & 0x0F) + 1; // MIDI channel (1-16)
            const data1 = data[1]; // Note number or CC number
            const data2 = data[2]; // Velocity or CC value

            const midiMessageString = `status: ${status.toString(16)}, type: ${type.toString(16)}, channel: ${channel}, data1: ${data1}, data2: ${data2}`;
            midiMonitor.textContent += midiMessageString + '\n';
            midiMonitor.scrollTop = midiMonitor.scrollHeight; // Scroll to bottom

            // If in MIDI learn mode
            if (isLearningMidi && learnTargetElement && channel === selectedMidiChannel) {
                let midiTypeString = '';
                let targetProperty = learnTargetElement.dataset.midiTarget;
                let minVal, maxVal, step;

                // Determine MIDI type and get target properties
                if (type === 0x90) { // Note On
                    midiTypeString = 'note on';
                    // For buttons, a Note On triggers it
                    // For sliders, note velocity can control it
                    if (learnTargetElement.tagName === 'BUTTON' || learnTargetElement.type === 'checkbox') {
                        // For buttons/checkboxes, we just need the note number and channel
                        minVal = 0; maxVal = 1; step = 1; // Binary state
                    } else if (learnTargetElement.type === 'range') {
                        minVal = parseFloat(learnTargetElement.min);
                        maxVal = parseFloat(learnTargetElement.max);
                        step = parseFloat(learnTargetElement.step);
                    } else if (learnTargetElement.tagName === 'SELECT') {
                        minVal = 0; maxVal = learnTargetElement.options.length - 1; step = 1;
                    } else if (learnTargetElement.type === 'color') { // Handle color inputs
                        minVal = 0; maxVal = 255; step = 1; // Map 0-127 MIDI to 0-255 color component
                    }
                } else if (type === 0x80) { // Note Off (can also be used for buttons)
                    midiTypeString = 'note off';
                    if (learnTargetElement.tagName === 'BUTTON' || learnTargetElement.type === 'checkbox') {
                        minVal = 0; maxVal = 1; step = 1;
                    }
                } else if (type === 0xB0) { // Control Change (CC)
                    midiTypeString = 'control change';
                    if (learnTargetElement.type === 'range') {
                        minVal = parseFloat(learnTargetElement.min);
                        maxVal = parseFloat(learnTargetElement.max);
                        step = parseFloat(learnTargetElement.step);
                    } else if (targetElement.tagName === 'SELECT') {
                        minVal = 0; maxVal = learnTargetElement.options.length - 1; step = 1;
                    } else if (targetElement.tagName === 'BUTTON' || targetElement.type === 'checkbox') {
                        minVal = 0; maxVal = 1; step = 1;
                    } else if (targetElement.type === 'color') { // Handle color inputs
                        minVal = 0; maxVal = 255; step = 1; // Map 0-127 MIDI to 0-255 color component
                    }
                } else {
                    // Ignore other MIDI messages for learning for now
                    return;
                }

                const newMapping = {
                    midiType: midiTypeString,
                    midiChannel: channel,
                    midiNumber: data1,
                    targetElementId: learnTargetElement.id,
                    targetProperty: targetProperty,
                    minVal: minVal,
                    maxVal: maxVal,
                    step: step,
                    elementTag: learnTargetElement.tagName,
                    elementType: learnTargetElement.type
                };

                // Check for duplicate mapping (same MIDI message to same control)
                const existingIndex = midiMappings.findIndex(m =>
                    m.midiType === newMapping.midiType &&
                    m.midiChannel === newMapping.midiChannel &&
                    m.midiNumber === newMapping.midiNumber &&
                    m.targetElementId === newMapping.targetElementId
                );

                if (existingIndex !== -1) {
                    midiMappings[existingIndex] = newMapping; // Update existing
                    showMessage(`¡mapeo actualizado para ${learnTargetElement.id}!`);
                } else {
                    midiMappings.push(newMapping); // Add new
                    showMessage(`¡mapeo creado: ${learnTargetElement.id} con midi ${midiTypeString} ${data1} en canal ${channel}!`);
                }

                stopMidiLearn(); // Stop learning after one mapping
                renderMidiMappings(); // Update the table
                return; // Don't apply the message yet, it was for learning
            }

            // Apply MIDI messages to mapped controls
            midiMappings.forEach(mapping => {
                if (mapping.midiChannel === channel && mapping.midiNumber === data1) {
                    const targetElement = document.getElementById(mapping.targetElementId);
                    if (!targetElement) return;

                    if (mapping.midiType === 'control change' && type === 0xB0) {
                        const normalizedValue = data2 / 127; // MIDI CC values are 0-127
                        const mappedValue = mapping.minVal + (normalizedValue * (mapping.maxVal - mapping.minVal));

                        if (targetElement.type === 'range') {
                            targetElement.value = mappedValue;
                            targetElement.dispatchEvent(new Event('input')); // Trigger input event
                        } else if (targetElement.tagName === 'SELECT') {
                            const optionIndex = Math.round(normalizedValue * (mapping.maxVal - mapping.minVal));
                            targetElement.value = targetElement.options[optionIndex].value;
                            targetElement.dispatchEvent(new Event('change')); // Trigger change event
                        } else if (targetElement.type === 'color') {
                            // Map MIDI CC (0-127) to a color component (0-255)
                            const colorValue = Math.round(normalizedValue * 255);
                            let currentColor = new THREE.Color(targetElement.value);
                            // Decide which component to map. For simplicity, let's map to Red for now.
                            // A more complex mapping would involve multiple CCs for R, G, B, or HSL.
                            currentColor.r = colorValue / 255; // Update red component
                            targetElement.value = '#' + currentColor.getHexString();
                            targetElement.dispatchEvent(new Event('input'));
                        }
                    } else if (mapping.midiType === 'note on' && type === 0x90 && data2 > 0) { // Note On with velocity > 0
                        if (targetElement.tagName === 'BUTTON') {
                            targetElement.click(); // Simulate click
                        } else if (targetElement.type === 'checkbox') {
                            targetElement.checked = !targetElement.checked;
                            targetElement.dispatchEvent(new Event('change'));
                        } else if (targetElement.type === 'range') {
                            // Map note velocity to slider value
                            const normalizedValue = data2 / 127;
                            const mappedValue = mapping.minVal + (normalizedValue * (mapping.maxVal - mapping.minVal));
                            targetElement.value = mappedValue;
                            targetElement.dispatchEvent(new Event('input'));
                        } else if (targetElement.type === 'color') {
                            // Map note velocity to a color component
                            const colorValue = Math.round(data2 / 127 * 255);
                            let currentColor = new THREE.Color(targetElement.value);
                            currentColor.g = colorValue / 255; // Update green component
                            targetElement.value = '#' + currentColor.getHexString();
                            targetElement.dispatchEvent(new Event('input'));
                        }
                        // Piano roll reactivity: Example - note number affects color speed
                        // This is a basic example. For "cada dos octavas", you'd need more complex logic.
                        // For instance, notes 60-71 (C4-B4) affect color speed, 72-83 (C5-B5) affect shape scale.
                        const noteNumber = data1;
                        const velocity = data2;
                        if (noteNumber >= 60 && noteNumber <= 71) { // C4 to B4
                            params.colorSpeed = 0.01 + (velocity / 127) * 0.49; // Map velocity to color speed range
                        } else if (noteNumber >= 72 && noteNumber <= 83) { // C5 to B5
                            params.shapeScale = 0.1 + (velocity / 127) * 1.9; // Map velocity to shape scale range
                        }
                    } else if (mapping.midiType === 'note off' && type === 0x80) { // Note Off
                        // For buttons/checkboxes, you might want to toggle back or reset
                        if (targetElement.type === 'checkbox') {
                            targetElement.checked = !targetElement.checked; // Toggle back on note off
                            targetElement.dispatchEvent(new Event('change'));
                        }
                    }
                }
            });
        }

        function renderMidiMappings() {
            midiMappingsTableBody.innerHTML = '';
            // Limit to 16 visible mappings in the table, even if more are stored
            const displayMappings = midiMappings.slice(0, 16);

            displayMappings.forEach((mapping, index) => {
                const row = midiMappingsTableBody.insertRow();
                row.insertCell().textContent = mapping.midiType;
                row.insertCell().textContent = mapping.midiChannel;
                row.insertCell().textContent = mapping.midiNumber;
                row.insertCell().textContent = mapping.targetElementId;
                const actionCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'borrar';
                deleteBtn.className = 'btn'; // Apply existing button style
                deleteBtn.onclick = () => {
                    // Delete by index in the original array, not in displayMappings
                    midiMappings.splice(midiMappings.indexOf(mapping), 1);
                    renderMidiMappings();
                    showMessage('mapeo borrado.');
                };
                actionCell.appendChild(deleteBtn);
            });

            // If there are more than 16 mappings, add a row indicating this
            if (midiMappings.length > 16) {
                const row = midiMappingsTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 5;
                cell.textContent = `... y ${midiMappings.length - 16} mapeos más (muestra limitada a 16)`;
                cell.style.textAlign = 'center';
                cell.style.fontStyle = 'italic';
                cell.style.color = '#a0aec0';
            }
        }

        function startMidiLearn() {
            isLearningMidi = true;
            midiLearnStatus.textContent = '¡modo de aprendizaje activado! haz clic en un control visual para mapearlo.';
            midiLearnStatus.classList.add('active');
            startMidiLearnBtn.style.display = 'none';
            stopMidiLearnBtn.style.display = 'block';
            document.body.classList.add('learn-mode-active'); // Add class to body for visual feedback

            // Add click listener to all mappable controls
            mappableControls.forEach(control => {
                // Ensure no duplicate listeners if startMidiLearn is called multiple times without stop
                control.removeEventListener('click', handleMappableControlClick);
                control.addEventListener('click', handleMappableControlClick, { once: true }); // Only listen once
            });
        }

        function handleMappableControlClick(event) {
            if (isLearningMidi) {
                learnTargetElement = event.currentTarget;
                midiLearnStatus.textContent = `control seleccionado: "${learnTargetElement.id}". ahora envía un mensaje midi desde tu controlador.`;
                // Remove click listeners from other controls to avoid multiple targets
                mappableControls.forEach(control => {
                    if (control !== learnTargetElement) {
                        control.removeEventListener('click', handleMappableControlClick);
                    }
                });
            }
        }

        function stopMidiLearn() {
            isLearningMidi = false;
            learnTargetElement = null;
            midiLearnStatus.textContent = '';
            midiLearnStatus.classList.remove('active');
            startMidiLearnBtn.style.display = 'block';
            stopMidiLearnBtn.style.display = 'none';
            document.body.classList.remove('learn-mode-active'); // Remove class from body

            // Remove all temporary click listeners
            mappableControls.forEach(control => {
                control.removeEventListener('click', handleMappableControlClick);
            });
        }

        function clearAllMidiMappings() {
            midiMappings = [];
            renderMidiMappings();
            showMessage('¡todos los mapeos midi borrados!');
        }

        // Function to enumerate media devices (audio input, video input)
        async function enumerateMediaDevices() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                showMessage('¡híjole! tu navegador no soporta la enumeración de dispositivos multimedia (micrófono/cámara) o está deshabilitada por la política de permisos. no podrás seleccionar dispositivos de entrada.');
                // Disable relevant UI
                audioInputSelect.disabled = true;
                cameraSelect.disabled = true;
                return;
            }

            try {
                // Request permissions for audio to ensure enumeration works
                await navigator.mediaDevices.getUserMedia({ audio: true, video: true }); // Request both for full enumeration

                const devices = await navigator.mediaDevices.enumerateDevices();
                audioInputSelect.innerHTML = '<option value="">-- selecciona entrada de audio --</option>';
                cameraSelect.innerHTML = '<option value="">-- selecciona cámara --</option>';

                devices.forEach(device => {
                    if (device.kind === 'audioinput') {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `micrófono ${audioInputSelect.options.length + 1}`;
                        audioInputSelect.appendChild(option);
                    } else if (device.kind === 'videoinput') {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `cámara ${cameraSelect.options.length + 1}`;
                        cameraSelect.appendChild(option);
                    }
                });
            } catch (err) {
                console.error('error al enumerar dispositivos multimedia:', err);
                showMessage('¡híjole! no pude enumerar los dispositivos de audio/cámara. esto suele pasar si los permisos están denegados por tu navegador o sistema operativo. revisa la configuración de permisos.');
                // Disable relevant UI on permission error
                audioInputSelect.disabled = true;
                cameraSelect.disabled = true;
                toggleAudioBtn.disabled = true;
                startCameraBtn.disabled = true;
                stopCameraBtn.disabled = true;
            }
        }


        // --- Event Listeners for Main Visualizer ---
        visualModeSelect.addEventListener('change', (e) => switchVisualMode(e.target.value));
        colorSpeedSlider.addEventListener('input', (e) => params.colorSpeed = parseFloat(e.target.value));
        amplitudeSensitivitySlider.addEventListener('input', (e) => params.amplitudeSensitivity = parseFloat(e.target.value));
        audioReactionThresholdSlider.addEventListener('input', (e) => params.audioReactionThreshold = parseInt(e.target.value));
        bassSensitivitySlider.addEventListener('input', (e) => params.bassSensitivity = parseFloat(e.target.value));
        midSensitivitySlider.addEventListener('input', (e) => params.midSensitivity = parseFloat(e.target.value));
        trebleSensitivitySlider.addEventListener('input', (e) => params.trebleSensitivity = parseFloat(e.target.value));
        layerOpacitySlider.addEventListener('input', (e) => params.layerOpacity = parseFloat(e.target.value));
        shapeScaleSlider.addEventListener('input', (e) => params.shapeScale = parseFloat(e.target.value));
        deformationLevelSlider.addEventListener('input', (e) => params.deformationLevel = parseFloat(e.target.value));
        materialModeSlider.addEventListener('input', (e) => {
            params.materialMode = parseInt(e.target.value);
            visualObjects.forEach(obj => {
                // Only update material mode for non-shader based visuals
                if (obj.mesh && obj.wireframe && obj.points) {
                    updateMaterialMode(obj, params.materialMode);
                }
            });
        });

        // Event Listeners for general background image/camera controls
        chromaKeyColorInput.addEventListener('input', (e) => {
            params.chromaKeyColor = e.target.value;
            // No need to update imagePlane uniforms here, it's done in animate loop
        });
        chromaKeyThresholdSlider.addEventListener('input', (e) => {
            params.chromaKeyThreshold = parseFloat(e.target.value);
            // No need to update imagePlane uniforms here, it's done in animate loop
        });
        backgroundScaleSlider.addEventListener('input', (e) => {
            params.backgroundScaleFactor = parseFloat(e.target.value);
            onWindowResize(); // Readjust image size
        });

        // NEW IMAGE EFFECT SLIDERS EVENT LISTENERS
        hueRotateSlider.addEventListener('input', (e) => {
            params.hueRotate = parseFloat(e.target.value);
        });
        saturationSlider.addEventListener('input', (e) => {
            params.saturation = parseFloat(e.target.value);
        });
        vignetteSlider.addEventListener('input', (e) => {
            params.vignette = parseFloat(e.target.value);
        });
        posterizeSlider.addEventListener('input', (e) => {
            params.posterize = parseFloat(e.target.value);
        });
        sharpenSlider.addEventListener('input', (e) => {
            params.sharpen = parseFloat(e.target.value);
        });
        scanlineSlider.addEventListener('input', (e) => {
            params.scanline = parseFloat(e.target.value);
        });

        // Camera specific controls
        startCameraBtn.addEventListener('click', () => {
            const deviceId = cameraSelect.value;
            if (deviceId) {
                startCameraAsBackground(deviceId);
            } else {
                showMessage('¡Selecciona una cámara primero, carnal!');
            }
        });
        stopCameraBtn.addEventListener('click', stopCameraAsBackground);

        cameraFilterModeSelect.addEventListener('change', (e) => {
            params.cameraFilterMode = parseInt(e.target.value);
        });
        cameraNoiseSlider.addEventListener('input', (e) => {
            params.cameraNoiseAmount = parseFloat(e.target.value) / 100.0; // Normalize to 0-1
        });
        cameraEdgeSensitivitySlider.addEventListener('input', (e) => {
            params.cameraEdgeSensitivity = parseFloat(e.target.value) / 100.0; // Normalize to 0-1
        });
        cameraBrightnessSlider.addEventListener('input', (e) => {
            params.cameraBrightness = parseFloat(e.target.value) / 100.0; // Normalize to -1 to 1
        });
        cameraContrastSlider.addEventListener('input', (e) => {
            params.cameraContrast = parseFloat(e.target.value) / 50.0; // Map 0-100 to 0.0-2.0 (1.0 is neutral)
        });
        cameraPixelateSizeSlider.addEventListener('input', (e) => {
            params.cameraPixelateSize = parseFloat(e.target.value);
        });
        cameraBlurAmountSlider.addEventListener('input', (e) => {
            params.cameraBlurAmount = parseFloat(e.target.value);
        });
        cameraMaterialSelect.addEventListener('change', (e) => {
            const selected = e.target.value;
            params.cameraMaterialColor.copy(backgroundMaterialColors[selected]);
        });


        grayscaleToggle.addEventListener('change', (e) => {
            params.grayscale = e.target.checked;
            // Update materials for all visual objects
            visualObjects.forEach((obj) => {
                if (obj.mesh && obj.mesh.material) {
                    if (obj.mesh.material.uniforms && obj.mesh.material.uniforms.grayscale) { // For shader materials
                        obj.mesh.material.uniforms.grayscale.value = params.grayscale;
                    } else { // For standard materials
                        applyMaterialColor(obj.mesh.material, obj.index);
                    }
                }
                if (obj.wireframe && obj.wireframe.material) {
                    applyMaterialColor(obj.wireframe.material, obj.index);
                }
                if (obj.points && obj.points.material) {
                    if (obj.points.geometry.attributes.color) {
                        const colors = obj.points.geometry.attributes.color.array;
                        const colorTemp = new THREE.Color();
                        for (let i = 0; i < obj.points.geometry.attributes.position.count; i++) {
                            colorTemp.copy(getCustomColor(i));
                            colors[i * 3] = colorTemp.r;
                            colors[i * 3 + 1] = colorTemp.g;
                            colors[i * 3 + 2] = colorTemp.b;
                        }
                        obj.points.geometry.attributes.color.needsUpdate = true;
                    } else {
                        applyMaterialColor(obj.points.material, obj.index);
                    }
                }
            });
        });

        colorInputs.forEach((input, index) => {
            input.addEventListener('input', (e) => {
                params.customColors[index] = e.target.value;
                visualObjects.forEach((obj) => {
                    if (obj.mesh && obj.mesh.material) {
                        if (obj.mesh.material.uniforms && obj.mesh.material.uniforms.customColor1) { // For shader materials
                            obj.mesh.material.uniforms[`customColor${index + 1}`].value.set(params.customColors[index]);
                        } else { // For standard materials
                            applyMaterialColor(obj.mesh.material, obj.index);
                        }
                    }
                    if (obj.wireframe && obj.wireframe.material) {
                        applyMaterialColor(obj.wireframe.material, obj.index);
                    }
                    if (obj.points && obj.points.material) {
                        if (obj.points.geometry.attributes.color) {
                            const colors = obj.points.geometry.attributes.color.array;
                            const colorTemp = new THREE.Color();
                            for (let i = 0; i < obj.points.geometry.attributes.position.count; i++) {
                                colorTemp.copy(getCustomColor(i));
                                colors[i * 3] = colorTemp.r;
                                colors[i * 3 + 1] = colorTemp.g;
                                colors[i * 3 + 2] = colorTemp.b;
                            }
                            obj.points.geometry.attributes.color.needsUpdate = true;
                        } else {
                            applyMaterialColor(obj.points.material, obj.index);
                        }
                    }
                });
            });
        });


        toggleAudioBtn.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'running') {
                stopAudio();
            } else {
                setupAudio(audioInputSelect.value); // Use selected audio input
            }
        });

        imageUploadInput.addEventListener('change', loadImageAsBackground);
        clearImageBtn.addEventListener('click', clearBackgroundImage); // Listener for the clear image button

        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    let errorMessage = '¡híjole! no se pudo activar la pantalla completa.';
                    if (err.name === 'NotAllowedError') {
                        errorMessage += ' probablemente tu navegador bloqueó la solicitud. asegúrate de hacer clic en el botón directamente o revisa los permisos.';
                    } else {
                        errorMessage += ` error: ${err.message}`;
                    }
                    showMessage(errorMessage);
                });
            } else {
                document.exitFullscreen();
            }
        });

        messageBoxOkBtn.addEventListener('click', () => {
            messageBox.style.display = 'none';
        });

        // MIDI Event Listeners
        midiInputSelect.addEventListener('change', (e) => {
            if (selectedMidiInput) {
                selectedMidiInput.onmidimessage = null; // Remove old listener
            }
            const inputId = e.target.value;
            selectedMidiInput = midiInputs.get(inputId);
            if (selectedMidiInput) {
                selectedMidiInput.onmidimessage = onMidiMessage; // Set new listener
                showMessage(`entrada midi seleccionada: ${selectedMidiInput.name}`);
            } else {
                showMessage('no se seleccionó ninguna entrada midi.');
            }
        });

        midiChannelInput.addEventListener('change', (e) => {
            selectedMidiChannel = parseInt(e.target.value);
            if (isNaN(selectedMidiChannel) || selectedMidiChannel < 1 || selectedMidiChannel > 16) {
                selectedMidiChannel = 1; // Default if invalid
                e.target.value = 1;
                showMessage('canal midi inválido. usando canal 1.');
            }
            showMessage(`canal midi establecido a: ${selectedMidiChannel}`);
        });

        startMidiLearnBtn.addEventListener('click', startMidiLearn);
        stopMidiLearnBtn.addEventListener('click', stopMidiLearn);
        clearMidiMappingsBtn.addEventListener('click', clearAllMidiMappings);


        // Event listeners for new profile buttons
        jucaProfileBtn.addEventListener('click', () => navigateToPage('jucaPage')); // Swapped order
        maroProfileBtn.addEventListener('click', () => navigateToPage('maroPage')); // Swapped order

        // Event listeners for all "Back" buttons
        backButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const targetPage = e.target.dataset.targetPage;
                navigateToPage(targetPage);
            });
        });

        // Event listener for camera selection (in left sidebar)
        cameraSelect.addEventListener('change', (event) => {
            // This select now just chooses the camera, the buttons activate/deactivate it.
            // No direct action here, but it updates the selected device for startCameraBtn.
        });


        window.onload = function() {
            initFirebase(); // Initialize Firebase first
            initThree(); // Initialize main visualizer Three.js
            switchVisualMode(currentVisualMode); // Set initial visual mode
            initMidi(); // Initialize MIDI on load
            enumerateMediaDevices(); // Enumerate media devices on load
            showMessage('¡qué onda! ¡bienvenido a tu generador de visuales! activa el audio o carga una imagen.');

            // Start the main visualizer animation loop by default
            renderer.setAnimationLoop(animateMainVisualizer);
        };

        const sidebarToggleLeft = document.getElementById('sidebarToggleLeft');
        const sidebarToggleRight = document.getElementById('sidebarToggleRight');
        const leftSidebarContainer = document.getElementById('leftSidebarContainer');
        const rightSidebarContainer = document.getElementById('rightSidebarContainer');

        // Toggle mobile sidebars
        function toggleSidebar(sidebar) {
            if (window.innerWidth <= 768) {
                sidebar.classList.toggle('hidden');
                sidebar.classList.toggle('active');
            }
        }

        // Add event listeners for the new mobile buttons
        sidebarToggleLeft.addEventListener('click', () => {
            toggleSidebar(leftSidebarContainer);
        });

        sidebarToggleRight.addEventListener('click', () => {
            toggleSidebar(rightSidebarContainer);
        });
        
        // This function needs to be updated to show/hide mobile buttons
        function onWindowResize() {
            // ... (Tu código original de onWindowResize) ...
            const isMobile = window.innerWidth <= 768;
            sidebarToggleLeft.style.display = isMobile ? 'block' : 'none';
            sidebarToggleRight.style.display = isMobile ? 'block' : 'none';
            
            // Hide sidebars on resize to mobile
            if (isMobile) {
                leftSidebarContainer.classList.add('hidden');
                leftSidebarContainer.classList.remove('active');
                rightSidebarContainer.classList.add('hidden');
                rightSidebarContainer.classList.remove('active');
            }
        }

        // Call onWindowResize when the page loads
        window.onload = function() {
            // ... (Tu código original de window.onload) ...
            onWindowResize(); // Adjust UI for initial screen size
        };
    </script>
</body>
</html>
