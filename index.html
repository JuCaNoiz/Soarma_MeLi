<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I | O</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* Base Styles */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap');
        html, body {
            margin: 0; padding: 0; height: 100%; overflow: hidden; position: relative; background-color: black;
            font-family: 'Space Mono', monospace; color: white;
        }
        canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; z-index: 0;
        }
        #app-container {
            position: relative; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; z-index: 1;
            padding-top: 7rem; padding-bottom: 5rem; padding-left: 300px; padding-right: 300px; box-sizing: border-box;
        }

        /* UI elements */
        .page {
            width: auto; height: auto; position: relative; flex-grow: 1; display: flex;
            flex-direction: column; align-items: center; justify-content: flex-start;
            transition: opacity 0.3s ease-in-out; box-sizing: border-box;
            padding-top: 0; padding-left: 1rem; padding-right: 1rem; overflow-y: auto;
        }
        .page.hidden {
            opacity: 0; pointer-events: none; display: none;
        }

        /* Global UI Containers (Responsivo) */
        .header-container, .footer-container {
            position: fixed; left: 50%; transform: translateX(-50%);
            width: auto; min-width: 300px; text-align: center; padding: 1rem 1.5rem;
            background-color: transparent; box-shadow: none; z-index: 10;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            box-sizing: border-box;
        }
        .header-container { top: 0; }
        .footer-container { bottom: 0; }
        .header-container.hidden { transform: translateX(-50%) translateY(-150%); opacity: 0; pointer-events: none; }
        .footer-container.hidden { transform: translateX(-50%) translateY(150%); opacity: 0; pointer-events: none; }
        .left-sidebar-container, .right-sidebar-container {
            position: fixed; top: 7rem; height: calc(100% - 7rem - 5rem); width: 300px;
            background-color: rgba(0, 0, 0, 0.8); z-index: 9; display: flex; flex-direction: column; padding: 0.75rem;
            box-sizing: border-box; transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        .left-sidebar-container { left: 0; border-right: 1px solid white; border-top-right-radius: 0.75rem; border-bottom-right-radius: 0.75rem; }
        .right-sidebar-container { right: 0; border-left: 1px solid white; border-top-left-radius: 0.75rem; border-bottom-left-radius: 0.75rem; }
        .left-sidebar-container.hidden { transform: translateX(-100%); opacity: 0; pointer-events: none; }
        .right-sidebar-container.hidden { transform: translateX(100%); opacity: 0; pointer-events: none; }
        
        /* Mobile Specific Styles */
        @media (max-width: 768px) {
            #app-container {
                padding-left: 0;
                padding-right: 0;
            }
            .header-container, .footer-container {
                position: fixed; left: 0; transform: none; width: 100%; min-width: unset; padding: 1rem;
            }
            .left-sidebar-container, .right-sidebar-container {
                top: unset; left: 0; right: 0; bottom: 0; width: 100%; height: 50vh; padding: 1rem;
                border-left: none; border-right: none; border-top: 1px solid white; border-radius: 0;
                transform: translateY(100%); transition: transform 0.3s ease-in-out;
            }
            .left-sidebar-container.active, .right-sidebar-container.active { transform: translateY(0); }
            #sidebarToggleLeft, #sidebarToggleRight {
                display: block; position: fixed; z-index: 20; top: 1rem; width: 40px; height: 40px;
                font-size: 1.5rem; background-color: rgba(255, 255, 255, 0.2); border: 1px solid white; border-radius: 8px;
            }
            #sidebarToggleLeft { left: 1rem; }
            #sidebarToggleRight { right: 1rem; }
            .right-sidebar-container.hidden, .left-sidebar-container.hidden { opacity: 1; pointer-events: auto; }
            .profile-page-content { margin-top: 5rem; padding: 1rem; }
            #audioDebugInfo { right: 1rem; top: 5rem; padding: 0.25rem; font-size: 0.6rem; }
        }

        /* Common styles from original code */
        .header-container h1 { font-family: 'Space Mono', monospace; font-size: 3rem; font-weight: 700; color: white; margin-bottom: 0.5rem; letter-spacing: 0.1em; text-transform: uppercase; }
        .header-container .description, .header-container .description-sub { font-family: 'Space Mono', monospace; color: white; margin-bottom: 0.25rem; text-transform: lowercase; }
        .header-container .description { font-size: 1.1rem; }
        .header-container .description-sub { font-size: 0.9rem; }
        .page .header-container .description { font-size: 1.7rem; }
        .page .header-container .description-sub { font-size: 1.5rem; }
        .social-buttons { display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; }
        .social-btn { font-family: 'Space Mono', monospace; display: flex; align-items: center; justify-content: center; width: auto; height: auto; padding: 0; font-size: 1.8rem; background-color: transparent; color: white; border-radius: 0; font-weight: bold; cursor: pointer; transition: transform 0.1s ease; box-shadow: none; border: none; text-decoration: none; text-transform: lowercase; }
        .social-btn:hover { transform: translateY(-2px); background-color: transparent; }
        .social-btn:active { transform: translateY(0); box-shadow: none; }
        .main-controls-scrollable { flex-grow: 1; overflow-y: auto; padding-right: 0.5rem; display: flex; flex-direction: column; gap: 1rem; }
        .main-controls-scrollable::-webkit-scrollbar { width: 8px; }
        .main-controls-scrollable::-webkit-scrollbar-track { background: #2d3748; border-radius: 10px; }
        .main-controls-scrollable::-webkit-scrollbar-thumb { background: white; border-radius: 10px; }
        .main-controls-scrollable::-webkit-scrollbar-thumb:hover { background: #cccccc; }
        .control-group-box { background-color: white; padding: 0.6rem; border-radius: 0.6rem; box-shadow: none; border: 1px solid black; display: flex; flex-direction: column; gap: 0.6rem; }
        .control-group-box h3 { font-family: 'Space Mono', monospace; font-size: 0.85rem; font-weight: bold; margin-bottom: 0.2rem; color: black; text-transform: lowercase; }
        .control-group { display: flex; flex-direction: column; gap: 0.4rem; }
        .control-group label { font-family: 'Space Mono', monospace; font-size: 0.75rem; color: black; text-transform: lowercase; }
        .control-group input[type="range"] { width: 100%; -webkit-appearance: none; height: 5px; background: black; border-radius: 3px; outline: none; opacity: 1; -webkit-transition: .2s; transition: opacity .2s; }
        .control-group input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; border-radius: 50%; background: white; cursor: pointer; box-shadow: 0 0 3px rgba(0, 0, 0, 0.5); }
        .control-group input[type="range"]::-moz-range-thumb { width: 14px; height: 14px; border-radius: 50%; background: white; cursor: pointer; box-shadow: 0 0 3px rgba(0, 0, 0, 0.5); }
        .control-group select.btn { font-family: 'Space Mono', monospace; padding: 0.4rem 0.6rem; font-size: 0.8rem; text-align: left; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M287%2C197.3L159.2%2C69.5c-3.2-3.2-8.4-3.2-11.6%2C0L5.4%2C197.3c-3.2%2C3.2-3.2%2C8.4%2C0%2C11.6l11.6%2C11.6c3.2%2C3.2%2C8.4%2C3.2%2C11.6%2C0l120.4-120.4l120.4%2C120.4c3.2%2C3.2%2C8.4%2C3.2%2C11.6%2C0l11.6-11.6C290.2%2C205.7%2C290.2%2C200.5%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 0.6rem center; background-size: 0.5em auto; background-color: white; color: black; border: 1px solid black; text-transform: lowercase; }
        .btn { font-family: 'Space Mono', monospace; background: white; color: black; padding: 0.6rem 1rem; border-radius: 0.6rem; font-weight: bold; cursor: pointer; transition: all 0.2s ease-in-out; box-shadow: none; border: 1px solid black; width: 100%; box-sizing: border-box; text-transform: lowercase; letter-spacing: 0.05em; }
        .btn:hover { background: #e0e0e0; transform: translateY(-2px); box-shadow: none; }
        .btn:active { transform: translateY(0); box-shadow: none; background: #cccccc; }
        .file-input-wrapper { position: relative; overflow: hidden; display: inline-block; width: 100%; }
        .file-input-wrapper input[type=file] { font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer; }
        .message-box { font-family: 'Space Mono', monospace; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; color: black; padding: 1.5rem; border-radius: 1rem; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); z-index: 1000; display: none; flex-direction: column; align-items: center; gap: 1rem; }
        .message-box button { font-family: 'Space Mono', monospace; background-color: black; color: white; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer; border: none; text-transform: lowercase; }
        .checkbox-group { display: flex; align-items: center; gap: 0.5rem; }
        .checkbox-group input[type="checkbox"] { width: 1.25rem; height: 1.25rem; accent-color: black; }
        .color-palette { display: flex; flex-direction: column; gap: 0.5rem; }
        .color-input-group { display: flex; align-items: center; gap: 0.5rem; }
        .color-input-group input[type="color"] { width: 40px; height: 25px; border: none; padding: 0; background: none; cursor: pointer; border-radius: 0.25rem; overflow: hidden; }
        .color-input-group input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .color-input-group input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.25rem; }
        .footer-text { font-family: 'Space Mono', monospace; font-size: 0.9rem; color: white; margin-bottom: 0.75rem; text-transform: lowercase; }
        .profile-buttons { display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap; }
        .profile-btn { font-family: 'Space Mono', monospace; background-color: transparent; color: white; padding: 0; border-radius: 0; font-weight: bold; cursor: pointer; transition: transform 0.1s ease; box-shadow: none; border: none; font-size: 1.2rem; text-transform: lowercase; }
        .profile-btn:hover { transform: translateY(-2px); background-color: transparent; }
        .profile-btn:active { transform: translateY(0); box-shadow: none; }
        #audioDebugInfo { font-family: 'Space Mono', monospace; position: fixed; top: 8rem; right: 310px; background-color: rgba(0, 0, 0, 0.5); color: white; padding: 0.5rem; border-radius: 0.5rem; font-size: 0.8rem; z-index: 100; display: none; text-transform: lowercase; }
        .profile-page-content { font-family: 'Space Mono', monospace; background-color: rgba(255, 255, 255, 0.1); padding: 2rem; border-radius: 0; box-shadow: none; max-width: 96%; width: 96%; margin-top: 7rem; text-align: left; overflow-y: auto; flex-grow: 1; box-sizing: border-box; display: flex; flex-direction: column; gap: 1rem; color: white; }
        .profile-page-content h2 { font-family: 'Space Mono', monospace; font-size: 2rem; font-weight: bold; color: white; margin-bottom: 1rem; text-align: center; text-transform: lowercase; }
        .profile-page-content h3 { font-family: 'Space Mono', monospace; font-size: 1.5rem; font-weight: bold; color: white; margin-top: 1.5rem; margin-bottom: 0.75rem; text-transform: lowercase; }
        .profile-page-content p, .profile-page-content ul { font-family: 'Space Mono', monospace; font-size: 1rem; line-height: 2; color: white; margin-bottom: 1rem; text-transform: lowercase; }
        .profile-page-content ul { list-style: disc; margin-left: 1.5rem; }
        .profile-page-content a { color: #ccc; text-decoration: underline; text-transform: lowercase; }
        .profile-page-content .project-image { max-width: 100%; height: auto; border-radius: 0.75rem; margin-top: 1rem; margin-bottom: 1rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }
        .back-btn-container { width: 100%; text-align: center; margin-top: 2rem; flex-shrink: 0; }
        .back-btn { font-family: 'Space Mono', monospace; background-color: black; color: white; padding: 0.8rem 1.8rem; border-radius: 0.75rem; font-weight: bold; cursor: pointer; transition: background-color 0.3s ease, transform 0.1s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08); border: none; text-transform: lowercase; }
        .back-btn:hover { background-color: #333; transform: translateY(-2px); }
        .back-btn:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .midi-control-group { display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1rem; }
        .midi-control-group label { font-family: 'Space Mono', monospace; font-size: 0.9rem; color: white; text-transform: lowercase; }
        .midi-control-group select, .midi-control-group input[type="number"] { font-family: 'Space Mono', monospace; background-color: white; border: 1px solid black; color: black; padding: 0.5rem; border-radius: 0.5rem; font-size: 0.9rem; text-transform: lowercase; }
        .midi-control-group button { width: auto; align-self: flex-start; }
        .midi-monitor { font-family: 'Space Mono', monospace; background-color: #f0f0f0; border: 1px solid black; padding: 0.6rem; border-radius: 0.6rem; font-size: 0.75rem; color: black; height: 80px; overflow-y: auto; white-space: pre-wrap; word-break: break-all; text-transform: lowercase; }
        .midi-mappings-table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
        .midi-mappings-table th, .midi-mappings-table td { font-family: 'Space Mono', monospace; border: 1px solid black; padding: 0.4rem; text-align: left; font-size: 0.8rem; text-transform: lowercase; }
        .midi-mappings-table th { background-color: black; color: white; }
        .midi-mappings-table td button { font-family: 'Space Mono', monospace; padding: 0.2rem 0.4rem; font-size: 0.7rem; border-radius: 0.5rem; background-color: black; color: white; text-transform: lowercase; }
        .midi-learn-status { font-family: 'Space Mono', monospace; background-color: black; color: white; padding: 0.75rem; border-radius: 0.75rem; text-align: center; font-weight: bold; margin-bottom: 1rem; display: none; text-transform: lowercase; }
        .midi-learn-status.active { display: block; }
        .learn-mode-active .mappable-control { border: 2px dashed white; cursor: crosshair; }
        .mappable-control:hover { box-shadow: 0 0 8px rgba(0, 0, 0, 0.7); }
    </style>
</head>
<body>
    <canvas id="visualCanvas"></canvas>

    <div id="app-container">
        <div id="mainVisualizerPage" class="page active">
            <button id="sidebarToggleLeft" class="btn hidden"><i class="fas fa-sliders-h"></i></button>
            <button id="sidebarToggleRight" class="btn hidden"><i class="fas fa-filter"></i></button>

            <div class="header-container" id="headerContainerMain">
                <h1>I | O</h1>
                <p class="description">"signal in, chaos out"</p>
                <p class="description-sub">música experimental + visuales</p>
                <div class="social-buttons">
                    <a href="https://www.tiktok.com/@juca.noiz" target="_blank" class="social-btn"><i class="fab fa-tiktok"></i></a>
                    <a href="https://www.instagram.com/jucanoiz/" target="_blank" class="social-btn"><i class="fab fa-instagram"></i></a>
                    <a href="https://www.facebook.com/juca.noiz.2025" target="_blank" class="social-btn"><i class="fab fa-facebook-f"></i></a>
                    <a href="https://www.youtube.com/@JuCa_Noiz" target="_blank" class="social-btn"><i class="fab fa-youtube"></i></a>
                </div>
            </div>

            <div class="left-sidebar-container" id="leftSidebarContainer">
                <div class="main-controls-scrollable">
                    <div class="control-group-box">
                        <h3>modo visual</h3>
                        <div class="control-group">
                            <label for="visualMode">seleccionar modo:</label>
                            <select id="visualMode" class="btn mappable-control" data-midi-target="visualMode">
                                <option value="spheres">esferas pulsantes</option>
                                <option value="particles">partículas reactivas</option>
                                <option value="waves">ondas de color</option>
                                <option value="cubes">cubos giratorios</option>
                                <option value="audioBars">barras de audio</option>
                                <option value="torus">toroides múltiples</option>
                                <option value="torusKnot">nudo toroide</option>
                                <option value="dodecahedron">dodecaedros múltiples</option>
                                <option value="icosahedron">icosaedros múltiples</option>
                                <option value="octahedron">octaedros múltiples</option>
                                <option value="cone">conos múltiples</option>
                                <option value="cylinder">cilindros múltiples</option>
                                <option value="ring">anillos múltiples</option>
                                <option value="tetrahedron">tetraedros múltiples</option>
                                <option value="multiTorus">multi-toroides</option>
                                <option value="gyroscope1">giroscopio de anillos</option>
                                <option value="gyroscope2">giroscopio de esferas anidadas</option>
                                <option value="gyroscope3">giroscopio de toroides intersectados</option>
                                <option value="fractalNoise">ruido fractal</option>
                                <option value="hydraFuego">hydra fuego cósmico</option>
                                <option value="hydraGlitch">hydra glitch dimension</option>
                                <option value="hydraTunel">hydra túnel espacial</option>
                            </select>
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>controles de visualización</h3>
                        <div class="control-group">
                            <label for="colorSpeed">vel. color:</label>
                            <input type="range" id="colorSpeed" min="0.01" max="0.5" step="0.01" value="0.1" class="mappable-control" data-midi-target="colorSpeed">
                        </div>
                        <div class="control-group">
                            <label for="amplitudeSensitivity">sens. audio general:</label>
                            <input type="range" id="amplitudeSensitivity" min="0.1" max="5.0" step="0.1" value="1.0" class="mappable-control" data-midi-target="amplitudeSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="audioReactionThreshold">umbral audio (db):</label>
                            <input type="range" id="audioReactionThreshold" min="0" max="255" step="1" value="45" class="mappable-control" data-midi-target="audioReactionThreshold">
                        </div>
                        <div class="control-group">
                            <label for="bassSensitivity">sens. graves:</label>
                            <input type="range" id="bassSensitivity" min="0.1" max="5.0" step="0.1" value="1.0" class="mappable-control" data-midi-target="bassSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="midSensitivity">sens. medios:</label>
                            <input type="range" id="midSensitivity" min="0.1" max="5.0" step="0.1" value="1.0" class="mappable-control" data-midi-target="midSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="trebleSensitivity">sens. agudos:</label>
                            <input type="range" id="trebleSensitivity" min="0.1" max="5.0" step="0.1" value="1.0" class="mappable-control" data-midi-target="trebleSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="layerOpacity">opacidad capa:</label>
                            <input type="range" id="layerOpacity" min="0.1" max="1.0" step="0.05" value="1.0" class="mappable-control" data-midi-target="layerOpacity">
                        </div>
                        <div class="control-group">
                            <label for="shapeScale">escala global:</label>
                            <input type="range" id="shapeScale" min="0.1" max="2.0" step="0.05" value="1.0" class="mappable-control" data-midi-target="shapeScale">
                        </div>
                        <div class="control-group">
                            <label for="deformationLevel">nivel deformación:</label>
                            <input type="range" id="deformationLevel" min="0.0" max="1.0" step="0.01" value="0.5" class="mappable-control" data-midi-target="deformationLevel">
                        </div>
                        <div class="control-group">
                            <label for="materialMode">modo material:</label>
                            <input type="range" id="materialMode" min="0" max="2" step="1" value="0" class="mappable-control" data-midi-target="materialMode">
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>opciones de color y más</h3>
                        <div class="checkbox-group">
                            <input type="checkbox" id="grayscaleToggle" class="mappable-control" data-midi-target="grayscaleToggle">
                            <label for="grayscaleToggle">escala de grises figuras</label>
                        </div>
                        <div class="color-palette">
                            <label>colores custom:</label>
                            <div class="color-input-group">
                                <input type="color" id="color1" value="#FF0000" class="mappable-control" data-midi-target="color1">
                                <input type="color" id="color2" value="#00FF00" class="mappable-control" data-midi-target="color2">
                                <input type="color" id="color3" value="#0000FF" class="mappable-control" data-midi-target="color3">
                            </div>
                            <div class="color-input-group">
                                <input type="color" id="color4" value="#FFFF00" class="mappable-control" data-midi-target="color4">
                                <input type="color" id="color5" value="#FF00FF" class="mappable-control" data-midi-target="color5">
                                <input type="color" id="color6" value="#00FFFF" class="mappable-control" data-midi-target="color6">
                            </div>
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>dispositivos de entrada</h3>
                        <div class="control-group">
                            <label for="audioInputSelect">entrada de audio:</label>
                            <select id="audioInputSelect" class="btn mappable-control" data-midi-target="audioInputSelect"></select>
                        </div>
                        <div class="control-group">
                            <label for="cameraSelect">seleccionar cámara:</label>
                            <select id="cameraSelect" class="btn mappable-control" data-midi-target="cameraSelect"></select>
                        </div>
                    </div>

                    <div class="control-group-box actions-box">
                        <h3>acciones</h3>
                        <button id="toggleAudio" class="btn mappable-control" data-midi-target="toggleAudio">activar audio</button>
                        <div class="file-input-wrapper">
                            <button class="btn">cargar imagen</button>
                            <input type="file" id="imageUpload" accept="image/*" multiple>
                        </div>
                        <button id="clearImageBtn" class="btn mappable-control" data-midi-target="clearImageBtn">borrar imagen de fondo</button>
                        <button id="fullscreenBtn" class="btn mappable-control" data-midi-target="fullscreenBtn">pantalla completa</button>
                    </div>
                </div>
            </div>

            <div class="right-sidebar-container" id="rightSidebarContainer">
                <div class="main-controls-scrollable">
                    <div class="control-group-box">
                        <h3>filtros de imagen de fondo</h3>
                        <div class="color-input-group">
                            <label for="chromaKeyColor">color chroma key:</label>
                            <input type="color" id="chromaKeyColor" value="#00FF00" class="mappable-control" data-midi-target="chromaKeyColor">
                        </div>
                        <div class="control-group">
                            <label for="chromaKeyThreshold">umbral chroma key:</label>
                            <input type="range" id="chromaKeyThreshold" min="0.0" max="0.5" step="0.01" value="0.001" class="mappable-control" data-midi-target="chromaKeyThreshold">
                        </div>
                        <div class="control-group">
                            <label for="backgroundScaleSlider">escala de fondo:</label>
                            <input type="range" id="backgroundScaleSlider" min="0.5" max="5.0" step="0.1" value="1.5" class="mappable-control" data-midi-target="backgroundScaleFactor">
                        </div>
                        <div class="control-group">
                            <label for="hueRotateSlider">rotación de tono:</label>
                            <input type="range" id="hueRotateSlider" min="0" max="360" step="1" value="0" class="mappable-control" data-midi-target="hueRotate">
                        </div>
                        <div class="control-group">
                            <label for="saturationSlider">saturación:</label>
                            <input type="range" id="saturationSlider" min="0" max="200" step="1" value="100" class="mappable-control" data-midi-target="saturation">
                        </div>
                        <div class="control-group">
                            <label for="vignetteSlider">viñeta:</label>
                            <input type="range" id="vignetteSlider" min="0" max="100" step="1" value="0" class="mappable-control" data-midi-target="vignette">
                        </div>
                        <div class="control-group">
                            <label for="posterizeSlider">posterizar:</label>
                            <input type="range" id="posterizeSlider" min="2" max="255" step="1" value="255" class="mappable-control" data-midi-target="posterize">
                        </div>
                        <div class="control-group">
                            <label for="sharpenSlider">nitidez:</label>
                            <input type="range" id="sharpenSlider" min="0" max="10" step="0.1" value="0" class="mappable-control" data-midi-target="sharpen">
                        </div>
                        <div class="control-group">
                            <label for="scanlineSlider">líneas de escaneo:</label>
                            <input type="range" id="scanlineSlider" min="0" max="100" step="1" value="0" class="mappable-control" data-midi-target="scanline">
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>controles de cámara</h3>
                        <button id="startCameraBtn" class="btn mappable-control" data-midi-target="startCameraBtn">activar cámara</button>
                        <button id="stopCameraBtn" class="btn mappable-control" data-midi-target="stopCameraBtn">detener cámara</button>
                        <div class="control-group">
                            <label for="cameraFilterModeSelect">filtro base:</label>
                            <select id="cameraFilterModeSelect" class="btn mappable-control" data-midi-target="cameraFilterModeSelect">
                                <option value="0">ninguno</option>
                                <option value="1">escala de grises</option>
                                <option value="2">invertir colores</option>
                                <option value="3">sepia</option>
                                <option value="4">pixelado</option>
                                <option value="5">desenfoque</option>
                                <option value="6">solo bordes</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="cameraNoiseSlider">ruido bordes:</label>
                            <input type="range" id="cameraNoiseSlider" min="0" max="100" value="0" class="mappable-control" data-midi-target="cameraNoiseAmount">
                        </div>
                        <div class="control-group">
                            <label for="cameraEdgeSensitivitySlider">sensibilidad bordes:</label>
                            <input type="range" id="cameraEdgeSensitivitySlider" min="0" max="100" value="50" class="mappable-control" data-midi-target="cameraEdgeSensitivity">
                        </div>
                        <div class="control-group">
                            <label for="cameraBrightnessSlider">brillo:</label>
                            <input type="range" id="cameraBrightnessSlider" min="-100" max="100" value="0" class="mappable-control" data-midi-target="cameraBrightness">
                        </div>
                        <div class="control-group">
                            <label for="cameraContrastSlider">contraste:</label>
                            <input type="range" id="cameraContrastSlider" min="0" max="100" value="50" class="mappable-control" data-midi-target="cameraContrast">
                        </div>
                        <div class="control-group">
                            <label for="cameraPixelateSizeSlider">tamaño pixel:</label>
                            <input type="range" id="cameraPixelateSizeSlider" min="1" max="50" value="1" class="mappable-control" data-midi-target="cameraPixelateSize">
                        </div>
                        <div class="control-group">
                            <label for="cameraBlurAmountSlider">intensidad desenfoque:</label>
                            <input type="range" id="cameraBlurAmountSlider" min="0" max="10" value="0" class="mappable-control" data-midi-target="cameraBlurAmount">
                        </div>
                        <div class="control-group">
                            <label for="cameraMaterialSelect">tinte bordes:</label>
                            <select id="cameraMaterialSelect" class="btn mappable-control" data-midi-target="cameraMaterialColor">
                                <option value="none">normal</option>
                                <option value="mercury">mercurio</option>
                                <option value="gold">oro</option>
                                <option value="lava">lava</option>
                                <option value="water">agua</option>
                            </select>
                        </div>
                    </div>

                    <div class="control-group-box">
                        <h3>control midi</h3>
                        <div class="midi-control-group">
                            <label for="midiInputSelect">entrada midi:</label>
                            <select id="midiInputSelect"></select>
                        </div>
                        <div class="midi-control-group">
                            <label for="midiOutputSelect">salida midi (futuro):</label>
                            <select id="midiOutputSelect"></select>
                        </div>
                        <div class="control-group">
                            <label for="midiChannelInput">canal midi (1-16):</label>
                            <input type="number" id="midiChannelInput" min="1" max="16" value="1">
                        </div>
                        <h3>modo de aprendizaje midi</h3>
                        <div class="midi-control-group">
                            <button id="startMidiLearnBtn" class="btn">iniciar aprendizaje midi</button>
                            <button id="stopMidiLearnBtn" class="btn" style="display: none;">detener aprendizaje midi</button>
                        </div>
                        <p id="midiLearnStatus" class="midi-learn-status">haz clic en un control visual para mapearlo.</p>
                        <h3>mapeos actuales</h3>
                        <button id="clearMidiMappingsBtn" class="btn">borrar todos los mapeos</button>
                        <table class="midi-mappings-table">
                            <thead>
                                <tr>
                                    <th>tipo midi</th>
                                    <th>canal</th>
                                    <th>número</th>
                                    <th>control visual</th>
                                    <th>acción</th>
                                </tr>
                            </thead>
                            <tbody id="midiMappingsTableBody"></tbody>
                        </table>
                        <h3>monitor midi</h3>
                        <div id="midiMonitor" class="midi-monitor"></div>
                    </div>
                </div>
            </div>

            <div class="footer-container" id="footerContainer">
                <p class="footer-text">creado por juca noiz | aural flux®</p>
                <div class="profile-buttons">
                    <button id="jucaProfileBtn" class="profile-btn">JuCa Noiz</button>
                    <button id="maroProfileBtn" class="profile-btn">Maro Valdivia</button>
                </div>
            </div>
        </div>

        <div id="jucaPage" class="page hidden">
            <div class="header-container">
                <h1>I | O</h1>
                <p class="description">JuCa Noiz</p>
                <p class="description-sub">ingeniero y diseñador de experiencias</p>
            </div>
            <div class="profile-page-content">
                <h2>perfil de JuCa Noiz</h2>
                <h3>biografía</h3>
                <p>JuCa Noiz es un ingeniero y diseñador de experiencias, especializado en la creación de paisajes sonoros y la integración de audio con visuales interactivos. su enfoque se centra en cómo el sonido puede moldear y ser moldeado por entornos visuales, explorando la sinestesia digital.</p>
                <p>con una profunda comprensión de la acústica y el procesamiento de señales, JuCa aporta una perspectiva técnica y artística a proyectos que buscan fusionar la música experimental con la interactividad visual, creando atmósferas envolventes y multisensoriales.</p>
                <h3>proyectos destacados</h3>
                <ul>
                    <li>I | O Web: una plataforma interactiva para la generación de visuales en tiempo real, donde el sonido y los controles MIDI dan vida a experiencias inmersivas.</li>
                    <li>Participación como sintetista en Tech-Noch: explorando la fusión de la cultura digital con las raíces sonoras más profundas, ¡creando un desmadre sonoro y visual que te vuela la cabeza!</li>
                    <li>"Resonance Chambers": una serie de experimentos sonoros que utilizan la resonancia de espacios físicos para generar visuales reactivos.</li>
                    <li>"Glitch Garden": un entorno interactivo donde los sonidos de la naturaleza son procesados y visualizados como fallas digitales.</li>
                    <li>"Sonic Sculptures": colaboraciones con escultores para crear piezas que emiten y reaccionan a estímulos sonoros.</li>
                </ul>
                <h3>filosofía artística</h3>
                <p>JuCa cree que el sonido es una fuerza fundamental en la experiencia humana, capaz de evocar emociones y transformar la percepción. su trabajo busca amplificar esta fuerza, utilizando la tecnología para revelar la belleza oculta en el ruido y la armonía, creando diálogos entre lo audible y lo visible.</p>
            </div>
            <div class="back-btn-container">
                <button class="back-btn" data-target-page="mainVisualizerPage">volver</button>
            </div>
        </div>

        <div id="maroPage" class="page hidden">
            <div class="header-container">
                <h1>I | O</h1>
                <p class="description">Maro Valdivia</p>
                <p class="description-sub">artista audiovisual</p>
            </div>
            <div class="profile-page-content">
                <h2>perfil de Maro Valdivia</h2>
                <h3>biografía</h3>
                <p>originario de Ciudad de México, Omar Valdivia es un artista multidisciplinario que fusiona elementos tradicionales y contemporáneos para crear experiencias sonoras y visuales únicas. su obra trasciende los límites convencionales, combinando diversos géneros y estilos para ofrecer composiciones innovadoras y cautivadoras. su habilidad para integrar diferentes disciplinas lo convierte en un creador de experiencias únicas, reflejando su profunda comprensión del arte como un medio en constante evolución.</p>
                <h3>Tech-Noch</h3>
                <p>Tech-Noch es un proyecto que explora la cultura y la tecnología a través de herramientas como el videomapping, la música y la creación digital, para generar experiencias visuales y auditivas inmersivas. Tech-Noch sirve como un puente entre el pasado y el futuro, ofreciendo una experiencia que vincula a las personas con sus raíces culturales, al tiempo que exploran las infinitas posibilidades de la tecnología.</p>
                <h3>apariciones destacadas</h3>
                <ul>
                    <li>Cryptofest, Tulúm, Q. Roo: videomapping con video proyecciones de colaboradores de Arteknov, sobre hongo de palma y lasers proyectados en lago. colaboración con Tulaaart, Arteknov.</li>
                    <li>Festival Prisma, Mérida, Yucatán: participación con video proyecciones como apoyo para la carrera de diseño y nuevos medios en el Gran Museo del Mundo Maya. colaboración con Universidad Anáhuac Mayab, Tulaaart.</li>
                    <li>Festival Naltik, Zacatlán, Puebla: colección de templos y pirámides proyectados con laser en las nubes sobrepuesto a la ciudad de Zacatlán de las Manzanas. videomapping al templo del "Señor del Cable" de la serie "Bandalismo Espiritual". colaboración con Transductor, Black3Labs.</li>
                    <li>Panteon MX, CDMX, MX: videomapping para inauguración de exposición del STP Crew. colaboración con Transductor, N30, STP Crew, Maldita Carmen, Meme.ZP.3KTRA, Fabs, Alibe, Nomoneynohoney.</li>
                    <li>Nektar, CDMX, MX y Toluca, Edo. Mex.: pre-lanzamiento de bebida Purple Haze de la marca Nektar, fiesta para influencers y artistas. colaboración con Sinestechnia, NEUG, WTS, Noise Diva.</li>
                    <li>Festival Data Uotan, CDMX, MX: participación con videomapping interactivo colaboración de obra de Ricardo Santos "Cocodrilos" para Festival Data Uotan patrocinado por la Embajada de Paises Bajos en México. colaboración con Ricardo Santos, NEUG, Uncloud, Alejandra Metztli.</li>
                    <li>"Abundance", CDMX, MX: participación para RE:INTEGRA. modelo: Michelle Favreau, artista de pintura: Bella Schauer, fotógrafo: Summer Hokulani, proyección: Tech-Noch.</li>
                </ul>
                <h3>contacto</h3>
                <p>web: <a href="https://www.omargarciavaldivia.com" target="_blank" style="color: white; text-decoration: underline;">www.omargarciavaldivia.com</a></p>
                <p>instagram: <a href="https://www.instagram.com/omar_valdivia" target="_blank" style="color: white; text-decoration: underline;">@omar_valdivia</a> / <a href="https://www.instagram.com/tech_noch" target="_blank" style="color: white; text-decoration: underline;">@tech_noch</a></p>
                <p>email: <a href="mailto:OMAR.G.VALDIVIA@GMAIL.COM" style="color: white; text-decoration: underline;">omar.g.valdivia@gmail.com</a></p>
            </div>
            <div class="back-btn-container">
                <button class="back-btn" data-target-page="mainVisualizerPage">volver</button>
            </div>
        </div>
    </div>

    <div id="audioDebugInfo">
        amplitud audio: <span id="currentAmplitude">0</span><br>
        nivel reacción: <span id="normalizedReaction">0.00</span><br>
        graves: <span id="bassAmplitude">0</span><br>
        medios: <span id="midAmplitude">0</span><br>
        agudos: <span id="trebleAmplitude">0</span>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxOk">ok</button>
    </div>

    <script type="module">
        // Global variables for Firebase (will be initialized if persistence is needed)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Three.js variables for main visualizer
        let scene, camera, renderer;
        let audioContext, analyser, microphone, dataArray;
        let currentVisualMode = 'spheres';
        let visualObjects = []; // To manage objects for each visual mode
        let particleBurstSystem = null; // Particle system for the "burst"

        // Background layers (camera related variables removed)
        let imagePlane = null;
        let videoFeed = null; // Reference to the video element for camera feed
        let videoTexture = null; // Three.js texture for the video feed
        let isCameraActive = false; // Flag to indicate if camera is active
        let currentCameraStream = null; // Global reference to the camera media stream

        // Variables for image carousel
        let loadedImageTextures = [];
        let currentImageIndex = -1;
        let imageChangeInterval = null;
        const IMAGE_CHANGE_INTERVAL_MS = 2500; // 2.5 seconds

        // MIDI variables
        let midiAccess = null;
        let midiInputs = new Map();
        let midiOutputs = new Map();
        let selectedMidiInput = null;
        let selectedMidiChannel = 1; // Default MIDI channel
        let isLearningMidi = false;
        let learnTargetElement = null; // The visualizer control element being mapped
        let midiMappings = []; // Array to store {midiType, midiChannel, midiNumber, targetElementId, targetProperty, minVal, maxVal, step}

        // Control parameters for main visualizer
        const params = {
            colorSpeed: 0.1,
            amplitudeSensitivity: 1.0,
            audioReactionThreshold: 45, // Audio threshold for reaction (0-255)
            bassSensitivity: 1.0, // New sensitivity for bass
            midSensitivity: 1.0,  // New sensitivity for mids
            trebleSensitivity: 1.0, // New sensitivity for trebles
            layerOpacity: 1.0,
            shapeScale: 1.0,
            deformationLevel: 0.5,
            materialMode: 0, // 0: Solid, 1: Wireframe, 2: Points
            grayscale: false, // For figures
            customColors: ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'],

            // Background parameters (general for image/camera)
            chromaKeyColor: '#00FF00', // Chroma key color (green by default), only for images
            chromaKeyThreshold: 0.001,   // Chroma key tolerance threshold (very low initial value), only for images
            backgroundScaleFactor: 1.5, // Background image/camera scale factor

            // NEW IMAGE EFFECTS
            hueRotate: 0.0, // 0-360 degrees
            saturation: 1.0, // 0.0 (grayscale) to 2.0 (super saturated), 1.0 is normal
            vignette: 0.0, // 0.0 (none) to 1.0 (full vignette)
            posterize: 255.0, // 2 to 255 (number of levels per color channel)
            sharpen: 0.0, // 0.0 (none) to 10.0 (very sharp)
            scanline: 0.0, // 0.0 (none) to 1.0 (full scanlines)

            // Camera specific parameters (applied to background shader when camera is active)
            cameraFilterMode: 0, // 0:none, 1:grayscale, 2:invert, 3:sepia, 4:pixelate, 5:blur, 6:edge-only
            cameraNoiseAmount: 0.0, // 0.0 - 1.0
            cameraEdgeSensitivity: 0.5, // 0.0 - 1.0 (mapped from 0-100 slider)
            cameraBrightness: 0.0, // -1.0 - 1.0 (mapped from -100-100 slider)
            cameraContrast: 1.0, // 0.0 - 2.0 (mapped from 0-100 slider, 1.0 is neutral)
            cameraPixelateSize: 1.0, // 1.0 - 50.0 (mapped from 1-50 slider)
            cameraBlurAmount: 0.0, // 0.0 - 10.0 (mapped from 0-10 slider)
            cameraMaterialColor: new THREE.Color(0xFFFFFF), // White by default for edge tinting
        };

        // Material colors for background edges
        const backgroundMaterialColors = {
            none: new THREE.Color(0xFFFFFF),
            mercury: new THREE.Color(0xA0B0C0),
            gold: new THREE.Color(0xFFD700),
            lava: new THREE.Color(0xFF4500),
            water: new THREE.Color(0x00BFFF)
        };

        // DOM element references for main visualizer
        const appContainer = document.getElementById('app-container');
        const mainVisualizerPage = document.getElementById('mainVisualizerPage');
        const headerContainerMain = document.getElementById('headerContainerMain');
        const leftSidebarContainer = document.getElementById('leftSidebarContainer');
        const rightSidebarContainer = document.getElementById('rightSidebarContainer');
        const footerContainer = document.getElementById('footerContainer');
        const visualCanvas = document.getElementById('visualCanvas');
        const visualModeSelect = document.getElementById('visualMode');
        const colorSpeedSlider = document.getElementById('colorSpeed');
        const amplitudeSensitivitySlider = document.getElementById('amplitudeSensitivity');
        const audioReactionThresholdSlider = document.getElementById('audioReactionThreshold');
        const bassSensitivitySlider = document.getElementById('bassSensitivity');
        const midSensitivitySlider = document.getElementById('midSensitivity');
        const trebleSensitivitySlider = document.getElementById('trebleSensitivity');
        const layerOpacitySlider = document.getElementById('layerOpacity');
        const shapeScaleSlider = document.getElementById('shapeScale');
        const deformationLevelSlider = document.getElementById('deformationLevel');
        const materialModeSlider = document.getElementById('materialMode');
        const grayscaleToggle = document.getElementById('grayscaleToggle');
        const colorInputs = Array.from({ length: 6 }, (_, i) => document.getElementById(`color${i + 1}`));
        const toggleAudioBtn = document.getElementById('toggleAudio');
        const imageUploadInput = document.getElementById('imageUpload');
        const clearImageBtn = document.getElementById('clearImageBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageBoxOkBtn = document.getElementById('messageBoxOk');
        const audioDebugInfo = document.getElementById('audioDebugInfo');
        const currentAmplitudeSpan = document.getElementById('currentAmplitude');
        const normalizedReactionSpan = document.getElementById('normalizedReaction');
        const bassAmplitudeSpan = document.getElementById('bassAmplitude');
        const midAmplitudeSpan = document.getElementById('midAmplitude');
        const trebleAmplitudeSpan = document.getElementById('trebleAmplitude');

        // Background filter controls
        const chromaKeyColorInput = document.getElementById('chromaKeyColor');
        const chromaKeyThresholdSlider = document.getElementById('chromaKeyThreshold');
        const backgroundScaleSlider = document.getElementById('backgroundScaleSlider');

        // NEW IMAGE EFFECT SLIDERS DOM ELEMENTS
        const hueRotateSlider = document.getElementById('hueRotateSlider');
        const saturationSlider = document.getElementById('saturationSlider');
        const vignetteSlider = document.getElementById('vignetteSlider');
        const posterizeSlider = document.getElementById('posterizeSlider');
        const sharpenSlider = document.getElementById('sharpenSlider');
        const scanlineSlider = document.getElementById('scanlineSlider');

        // Camera specific controls
        const startCameraBtn = document.getElementById('startCameraBtn');
        const stopCameraBtn = document.getElementById('stopCameraBtn');
        const cameraFilterModeSelect = document.getElementById('cameraFilterModeSelect');
        const cameraNoiseSlider = document.getElementById('cameraNoiseSlider');
        const cameraEdgeSensitivitySlider = document.getElementById('cameraEdgeSensitivitySlider');
        const cameraBrightnessSlider = document.getElementById('cameraBrightnessSlider');
        const cameraContrastSlider = document.getElementById('cameraContrastSlider');
        const cameraPixelateSizeSlider = document.getElementById('cameraPixelateSizeSlider');
        const cameraBlurAmountSlider = document.getElementById('cameraBlurAmountSlider');
        const cameraMaterialSelect = document.getElementById('cameraMaterialSelect');

        // Profile buttons
        const maroProfileBtn = document.getElementById('maroProfileBtn');
        const jucaProfileBtn = document.getElementById('jucaProfileBtn');
        const maroPage = document.getElementById('maroPage');
        const jucaPage = document.getElementById('jucaPage');
        const backButtons = document.querySelectorAll('.back-btn');

        // MIDI section elements
        const midiInputSelect = document.getElementById('midiInputSelect');
        const midiOutputSelect = document.getElementById('midiOutputSelect');
        const midiChannelInput = document.getElementById('midiChannelInput');
        const startMidiLearnBtn = document.getElementById('startMidiLearnBtn');
        const stopMidiLearnBtn = document.getElementById('stopMidiLearnBtn');
        const midiLearnStatus = document.getElementById('midiLearnStatus');
        const midiMappingsTableBody = document.getElementById('midiMappingsTableBody');
        const midiMonitor = document.getElementById('midiMonitor');
        const clearMidiMappingsBtn = document.getElementById('clearMidiMappingsBtn');

        // Input device selection elements
        const audioInputSelect = document.getElementById('audioInputSelect');
        const cameraSelect = document.getElementById('cameraSelect');

        // All mappable controls (add data-midi-target="id" in HTML)
        const mappableControls = document.querySelectorAll('.mappable-control');
        
        // New mobile toggle buttons
        const sidebarToggleLeft = document.getElementById('sidebarToggleLeft');
        const sidebarToggleRight = document.getElementById('sidebarToggleRight');

        // --- Firebase Init ---
        const initFirebase = async () => {
            try {
                // Check if Firebase libraries are available
                if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                    console.warn("Firebase no está disponible. Las funciones de persistencia y análisis no estarán activas.");
                    return;
                }
                app = firebase.initializeApp(firebaseConfig);
                db = firebase.firestore(app);
                auth = firebase.auth(app);

                if (initialAuthToken) {
                    await auth.signInWithCustomToken(initialAuthToken);
                } else {
                    await auth.signInAnonymously();
                }
                userId = auth.currentUser?.uid || crypto.randomUUID();
                console.log("Firebase initialized and user authenticated:", userId);
            } catch (error) {
                console.error("Error al inicializar Firebase o autenticar:", error);
                showMessage("¡Ojo! Hubo un error al iniciar Firebase. Algunas funciones podrían no jalar bien.");
            }
        };

        // Function to show custom messages
        function showMessage(message) {
            messageText.textContent = message;
            messageBox.style.display = 'flex';
        }

        // Function to navigate between pages (only for Maro/JuCa)
        function navigateToPage(pageId) {
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => {
                if (page.id === pageId) {
                    page.classList.remove('hidden');
                    if (pageId === 'mainVisualizerPage') {
                        headerContainerMain.classList.remove('hidden');
                        leftSidebarContainer.classList.remove('hidden');
                        rightSidebarContainer.classList.remove('hidden');
                        footerContainer.classList.remove('hidden');
                        if (audioContext && audioContext.state === 'running') {
                            audioDebugInfo.style.display = 'block';
                        }
                        if (renderer.setAnimationLoop) {
                            renderer.setAnimationLoop(animateMainVisualizer);
                        }
                    } else {
                        const currentProfileHeader = page.querySelector('.header-container');
                        const currentProfileContent = page.querySelector('.profile-page-content');
                        if (currentProfileHeader) currentProfileHeader.classList.remove('hidden');
                        if (currentProfileContent) currentProfileContent.style.display = 'flex';
                        headerContainerMain.classList.add('hidden');
                        leftSidebarContainer.classList.add('hidden');
                        rightSidebarContainer.classList.add('hidden');
                        footerContainer.classList.add('hidden');
                        audioDebugInfo.style.display = 'none';
                        stopCameraAsBackground();
                        if (renderer.setAnimationLoop) {
                            renderer.setAnimationLoop(null);
                        }
                    }
                } else {
                    page.classList.add('hidden');
                }
            });
            onWindowResize();
        }

        // --- Main Visualizer Three.js Init and Resize ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: visualCanvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.setPixelRatio(window.devicePixelRatio);

            camera.position.z = 5;

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            const planeGeometry = new THREE.PlaneGeometry(2, 2);

            imagePlane = new THREE.Mesh(planeGeometry, new THREE.ShaderMaterial({
                uniforms: {
                    backgroundTexture: { value: null },
                    isCameraActive: { value: false },
                    chromaKeyColor: { value: new THREE.Color(params.chromaKeyColor) },
                    chromaKeyThreshold: { value: params.chromaKeyThreshold },
                    backgroundFilterMode: { value: params.cameraFilterMode },
                    backgroundNoiseAmount: { value: params.cameraNoiseAmount },
                    backgroundEdgeSensitivity: { value: params.cameraEdgeSensitivity },
                    backgroundBrightness: { value: params.cameraBrightness },
                    backgroundContrast: { value: params.cameraContrast },
                    backgroundPixelateSize: { value: params.cameraPixelateSize },
                    backgroundBlurAmount: { value: params.cameraBlurAmount },
                    backgroundMaterialColor: { value: params.cameraMaterialColor },
                    audioVolume: { value: 0.0 },
                    time: { value: 0.0 },
                    uHueRotate: { value: params.hueRotate * Math.PI / 180.0 },
                    uSaturation: { value: params.saturation / 100.0 },
                    uVignette: { value: params.vignette / 100.0 },
                    uPosterizeLevels: { value: params.posterize },
                    uSharpenAmount: { value: params.sharpen },
                    uScanlineDensity: { value: params.scanline / 100.0 },
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D backgroundTexture;
                    uniform bool isCameraActive;
                    uniform vec3 chromaKeyColor;
                    uniform float chromaKeyThreshold;
                    uniform int backgroundFilterMode;
                    uniform float backgroundNoiseAmount;
                    uniform float backgroundEdgeSensitivity;
                    uniform float backgroundBrightness;
                    uniform float backgroundContrast;
                    uniform float backgroundPixelateSize;
                    uniform float backgroundBlurAmount;
                    uniform vec3 backgroundMaterialColor;
                    uniform float audioVolume;
                    uniform float time;
                    uniform float uHueRotate;
                    uniform float uSaturation;
                    uniform float uVignette;
                    uniform float uPosterizeLevels;
                    uniform float uSharpenAmount;
                    uniform float uScanlineDensity;
                    varying vec2 vUv;
                    float hash(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }
                    float noise(vec2 st) {
                        vec2 i = floor(st); vec2 f = fract(st); vec2 u = f * f * (3.0 - 2.0 * f);
                        float a = hash(i); float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0));
                        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
                    }
                    float toGrayscale(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }
                    vec3 applyBrightnessContrast(vec3 color, float bright, float cont) {
                        color += bright; color = (color - 0.5) * cont + 0.5;
                        return clamp(color, 0.0, 1.0);
                    }
                    vec3 applySepia(vec3 color) {
                        float r = color.r; float g = color.g; float b = color.b;
                        vec3 sepiaColor;
                        sepiaColor.r = min(1.0, (r * 0.393) + (g * 0.769) + (b * 0.189));
                        sepiaColor.g = min(1.0, (r * 0.349) + (g * 0.686) + (b * 0.168));
                        sepiaColor.b = min(1.0, (r * 0.272) + (g * 0.534) + (b * 0.131));
                        return sepiaColor;
                    }
                    vec3 rgbToHsv(vec3 c) {
                        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                        float d = q.x - min(q.w, q.y);
                        float e = 1.0e-10;
                        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
                    }
                    vec3 hsvToRgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.x, 0.0, 1.0), c.y);
                    }
                    vec3 adjustSaturation(vec3 color, float sat) {
                        vec3 gray = vec3(dot(color, vec3(0.299, 0.587, 0.114)));
                        return mix(gray, color, sat);
                    }
                    vec3 applyVignette(vec3 color, float vignetteAmount) {
                        vec2 uv_centered = vUv - 0.5;
                        float dist = length(uv_centered);
                        float vignette = smoothstep(0.4, 0.8, dist);
                        return mix(color, color * (1.0 - vignetteAmount), vignette);
                    }
                    vec3 applyPosterize(vec3 color, float levels) { return floor(color * levels) / levels; }
                    vec3 applySharpen(sampler2D tex, vec2 uv, float amount) {
                        vec2 texelSize = 1.0 / vec2(textureSize(tex, 0)); vec3 sum = vec3(0.0);
                        sum += texture2D(tex, uv + texelSize * vec2(-1, -1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2( 0, -1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2( 1, -1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2(-1,  0)).rgb * -0.07;
                        sum += texture2D(tex, uv).rgb * (1.0 + 8.0 * 0.07);
                        sum += texture2D(tex, uv + texelSize * vec2( 1,  0)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2(-1,  1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2( 0,  1)).rgb * -0.07;
                        sum += texture2D(tex, uv + texelSize * vec2( 1,  1)).rgb * -0.07;
                        return mix(texture2D(tex, uv).rgb, sum, amount);
                    }
                    vec3 applyScanline(vec3 color, float density) {
                        float scanline = sin(vUv.y * 500.0) * 0.05 * density;
                        return color * (1.0 - scanline);
                    }
                    void main() {
                        vec4 texColor = texture2D(backgroundTexture, vUv);
                        vec3 finalColor = texColor.rgb;
                        if (!isCameraActive) {
                            vec3 diff = finalColor - chromaKeyColor;
                            float dist = length(diff);
                            if (dist < chromaKeyThreshold) { discard; }
                        }
                        finalColor = applyBrightnessContrast(finalColor, backgroundBrightness, backgroundContrast);
                        if (isCameraActive && backgroundFilterMode == 6) {
                            float currentGray = toGrayscale(finalColor);
                            vec2 texelSize = 1.0 / vec2(textureSize(backgroundTexture, 0));
                            float gX = 0.0; float gY = 0.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, -1)).rgb) * -1.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, 0)).rgb) * -2.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, 1)).rgb) * -1.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, -1)).rgb) * 1.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, 0)).rgb) * 2.0;
                            gX += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, 1)).rgb) * 1.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, -1)).rgb) * -1.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + vec2(0, -1) * texelSize).rgb) * -2.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, -1)).rgb) * -1.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(-1, 1)).rgb) * 1.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(0, 1)).rgb) * 2.0;
                            gY += toGrayscale(texture2D(backgroundTexture, vUv + texelSize * vec2(1, 1)).rgb) * 1.0;
                            float edgeStrength = sqrt(gX * gX + gY * gY);
                            float dynamicEdgeThreshold = mix(0.3, 0.05, backgroundEdgeSensitivity);
                            dynamicEdgeThreshold = max(0.0, dynamicEdgeThreshold - audioVolume * 0.2);
                            finalColor = vec3(0.0);
                            if (edgeStrength > dynamicEdgeThreshold) { finalColor = backgroundMaterialColor; }
                        } else if (isCameraActive) {
                            if (backgroundFilterMode == 1) { float gray = toGrayscale(finalColor); finalColor = vec3(gray); }
                            else if (backgroundFilterMode == 2) { finalColor = vec3(1.0 - finalColor.r, 1.0 - finalColor.g, 1.0 - finalColor.b); }
                            else if (backgroundFilterMode == 3) { finalColor = applySepia(finalColor); }
                            else if (backgroundFilterMode == 4) {
                                vec2 texelSize = 1.0 / vec2(textureSize(backgroundTexture, 0));
                                vec2 pixelatedUV = floor(vUv * backgroundPixelateSize) / backgroundPixelateSize;
                                finalColor = texture2D(backgroundTexture, pixelatedUV).rgb;
                            }
                            else if (backgroundFilterMode == 5) {
                                vec2 texelSize = 1.0 / vec2(textureSize(backgroundTexture, 0)); vec3 blurredColor = vec3(0.0); float count = 0.0;
                                for (float y = -backgroundBlurAmount; y <= backgroundBlurAmount; y += 1.0) {
                                    for (float x = -backgroundBlurAmount; x <= backgroundBlurAmount; x += 1.0) {
                                        blurredColor += texture2D(backgroundTexture, vUv + vec2(x, y) * texelSize).rgb; count += 1.0;
                                    }
                                }
                                finalColor = blurredColor / count;
                            }
                        } else {
                            if (uHueRotate != 0.0) {
                                vec3 hsv = rgbToHsv(finalColor); hsv.x = fract(hsv.x + uHueRotate / (2.0 * 3.14159));
                                finalColor = hsvToRgb(hsv);
                            }
                            if (uSaturation != 1.0) { finalColor = adjustSaturation(finalColor, uSaturation); }
                            if (uVignette > 0.0) { finalColor = applyVignette(finalColor, uVignette); }
                            if (uPosterizeLevels < 255.0) { finalColor = applyPosterize(finalColor, uPosterizeLevels); }
                            if (uSharpenAmount > 0.0) { finalColor = applySharpen(backgroundTexture, vUv, uSharpenAmount); }
                            if (uScanlineDensity > 0.0) { finalColor = applyScanline(finalColor, uScanlineDensity); }
                        }
                        float n = noise(vUv * 100.0 + time * 0.5) * 2.0 - 1.0;
                        finalColor += n * backgroundNoiseAmount;
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.NormalBlending,
                depthWrite: false,
            }));
            imagePlane.position.z = -99;
            imagePlane.visible = false;
            scene.add(imagePlane);
            videoFeed = document.createElement('video');
            videoFeed.autoplay = true; videoFeed.playsInline = true; videoFeed.style.display = 'none';
            document.body.appendChild(videoFeed);
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('fullscreenchange', onFullscreenChange);
        }

        function onWindowResize() {
            const isMobile = window.innerWidth <= 768;
            sidebarToggleLeft.style.display = isMobile ? 'block' : 'none';
            sidebarToggleRight.style.display = isMobile ? 'block' : 'none';
            if (isMobile) {
                leftSidebarContainer.classList.add('hidden');
                leftSidebarContainer.classList.remove('active');
                rightSidebarContainer.classList.add('hidden');
                rightSidebarContainer.classList.remove('active');
            }

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (imagePlane && imagePlane.visible && imagePlane.material.uniforms.backgroundTexture && imagePlane.material.uniforms.backgroundTexture.value) {
                const texture = imagePlane.material.uniforms.backgroundTexture.value;
                const textureAspect = (texture.image && texture.image.videoWidth) ? texture.image.videoWidth / texture.image.videoHeight : (texture.image ? texture.image.width / texture.image.height : 1);
                const viewHeight = 2 * Math.tan(camera.fov * Math.PI / 360) * Math.abs(imagePlane.position.z - camera.position.z);
                const viewWidth = viewHeight * camera.aspect;
                let scaleX, scaleY;
                if (viewWidth / textureAspect >= viewHeight) {
                    scaleX = viewWidth * params.backgroundScaleFactor;
                    scaleY = (viewWidth / textureAspect) * params.backgroundScaleFactor;
                } else {
                    scaleX = (viewHeight * textureAspect) * params.backgroundScaleFactor;
                    scaleY = viewHeight * params.backgroundScaleFactor;
                }
                imagePlane.scale.set(scaleX, scaleY, 1);
            }
            if (currentVisualMode === 'fractalNoise' && visualObjects.length > 0 && visualObjects[0].mesh) {
                const plane = visualObjects[0].mesh;
                const viewHeight = 2 * Math.tan(camera.fov * Math.PI / 360) * Math.abs(camera.position.z - plane.position.z);
                const viewWidth = viewHeight * camera.aspect;
                plane.scale.set(viewWidth, viewHeight, 1);
            }
            if ((currentVisualMode === 'hydraFuego' || currentVisualMode === 'hydraGlitch' || currentVisualMode === 'hydraTunel') && visualObjects.length > 0 && visualObjects[0].mesh) {
                const plane = visualObjects[0].mesh;
                const viewHeight = 2 * Math.tan(camera.fov * Math.PI / 360) * Math.abs(camera.position.z - plane.position.z);
                const viewWidth = viewHeight * camera.aspect;
                plane.scale.set(viewWidth, viewHeight, 1);
            }
        }

        function onFullscreenChange() {
            const allHeaders = document.querySelectorAll('.header-container');
            const allSidebars = [leftSidebarContainer, rightSidebarContainer];
            const allFooters = [footerContainer];
            const allProfileContents = document.querySelectorAll('.profile-page-content');
            if (document.fullscreenElement) {
                allHeaders.forEach(el => el.classList.add('hidden'));
                allSidebars.forEach(el => el.classList.add('hidden'));
                allFooters.forEach(el => el.classList.add('hidden'));
                allProfileContents.forEach(el => el.style.display = 'none');
                audioDebugInfo.style.display = 'none';
                showMessage('¡pantalla completa activada! presiona esc para salir.');
            } else {
                const currentPage = document.querySelector('.page:not(.hidden)');
                if (currentPage && currentPage.id === 'mainVisualizerPage') {
                    headerContainerMain.classList.remove('hidden');
                    leftSidebarContainer.classList.remove('hidden');
                    rightSidebarContainer.classList.remove('hidden');
                    footerContainer.classList.remove('hidden');
                    if (audioContext && audioContext.state === 'running') {
                        audioDebugInfo.style.display = 'block';
                    }
                } else if (currentPage && (currentPage.id === 'maroPage' || currentPage.id === 'jucaPage')) {
                    const currentProfileHeader = currentPage.querySelector('.header-container');
                    const currentProfileContent = currentPage.querySelector('.profile-page-content');
                    if (currentProfileHeader) currentProfileHeader.classList.remove('hidden');
                    if (currentProfileContent) currentProfileContent.style.display = 'flex';
                }
            }
            onWindowResize();
        }

        // --- Functions for different visual modes ---
        function clearVisuals() {
            visualObjects.forEach(obj => {
                if (obj.mesh) {
                    if (obj.mesh.geometry) obj.mesh.geometry.dispose();
                    if (obj.mesh.material) {
                        if (Array.isArray(obj.mesh.material)) {
                            obj.mesh.material.forEach(m => m.dispose());
                        } else {
                            obj.mesh.material.dispose();
                        }
                    }
                    scene.remove(obj.mesh);
                }
                if (obj.wireframe) {
                    if (obj.wireframe.geometry) obj.wireframe.geometry.dispose();
                    if (obj.wireframe.material) {
                        if (Array.isArray(obj.wireframe.material)) {
                            obj.wireframe.material.forEach(m => m.dispose());
                        } else {
                            obj.wireframe.material.dispose();
                        }
                    }
                    scene.remove(obj.wireframe);
                }
                if (obj.points) {
                    if (obj.points.geometry) obj.points.geometry.dispose();
                    if (obj.points.material) {
                        if (Array.isArray(obj.points.material)) {
                            obj.points.material.forEach(m => m.dispose());
                        } else {
                            obj.points.material.dispose();
                        }
                    }
                    scene.remove(obj.points);
                }
            });
            visualObjects = [];
            if (particleBurstSystem) {
                scene.remove(particleBurstSystem);
                particleBurstSystem.geometry.dispose();
                particleBurstSystem.material.dispose();
                particleBurstSystem = null;
            }
        }

        function getCustomColor(index) {
            const hex = params.customColors[index % params.customColors.length];
            const color = new THREE.Color(hex);
            if (params.grayscale) {
                const gray = color.r * 0.299 + color.g * 0.587 + color.b * 0.114;
                color.setRGB(gray, gray, gray);
            }
            return color;
        }

        function applyMaterialColor(material, customColorIndex) {
            material.color.copy(getCustomColor(customColorIndex));
        }

        function createGeometricObject(geometry, index) {
            const solidMaterial = new THREE.MeshPhongMaterial({ color: getCustomColor(index), transparent: true, opacity: params.layerOpacity });
            const wireframeMaterial = new THREE.MeshBasicMaterial({ color: getCustomColor(index), wireframe: true, transparent: true, opacity: params.layerOpacity });
            const pointsMaterial = new THREE.PointsMaterial({ color: getCustomColor(index), size: 0.1, transparent: true, opacity: params.layerOpacity, blending: THREE.AdditiveBlending });

            const mesh = new THREE.Mesh(geometry, solidMaterial);
            const wireframe = new THREE.Mesh(geometry, wireframeMaterial);
            const points = new THREE.Points(geometry, pointsMaterial);

            const deformableGeometry = geometry.clone();
            deformableGeometry.userData.originalPositions = Array.from(deformableGeometry.attributes.position.array);
            mesh.geometry = deformableGeometry;
            wireframe.geometry = deformableGeometry;
            points.geometry = deformableGeometry;

            const obj = { mesh, wireframe, points, index };
            scene.add(mesh);
            scene.add(wireframe);
            scene.add(points);
            updateMaterialMode(obj, params.materialMode);
            return obj;
        }

        function updateMaterialMode(obj, mode) {
            if (obj.mesh) obj.mesh.visible = (mode === 0);
            if (obj.wireframe) obj.wireframe.visible = (mode === 1);
            if (obj.points) obj.points.visible = (mode === 2);
        }

        function applyDeformation(obj, normalizedAmplitude, deformationLevel) {
            const geometry = obj.mesh.geometry;
            const positions = geometry.attributes.position.array;
            const originalPositions = geometry.userData.originalPositions;
            if (!originalPositions) return;
            for (let i = 0; i < positions.length; i += 3) {
                const originalX = originalPositions[i];
                const originalY = originalPositions[i + 1];
                const originalZ = originalPositions[i + 2];
                positions[i] = originalX * (1 + Math.sin(performance.now() * 0.005 + originalX * 0.1) * normalizedAmplitude * deformationLevel * 0.5);
                positions[i + 1] = originalY * (1 + Math.cos(performance.now() * 0.005 + originalY * 0.1) * normalizedAmplitude * deformationLevel * 0.5);
                positions[i + 2] = originalZ * (1 + Math.sin(performance.now() * 0.005 + originalZ * 0.1) * normalizedAmplitude * deformationLevel * 0.5);
            }
            geometry.attributes.position.needsUpdate = true;
        }

        function createSpheresVisual() {
            clearVisuals();
            const numSpheres = 20;
            for (let i = 0; i < numSpheres; i++) {
                const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createParticlesVisual() {
            clearVisuals();
            const numParticles = 20000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(numParticles * 3);
            const originalPositions = new Float32Array(numParticles * 3);
            const colors = new Float32Array(numParticles * 3);
            for (let i = 0; i < numParticles; i++) {
                const x = (Math.random() - 0.5) * 20;
                const y = (Math.random() - 0.5) * 20;
                const z = (Math.random() - 0.5) * 20;
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                originalPositions[i * 3] = x;
                originalPositions[i * 3 + 1] = y;
                originalPositions[i * 3 + 2] = z;
                const color = getCustomColor(i);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({ size: 0.1, vertexColors: true, transparent: true, opacity: params.layerOpacity, blending: THREE.AdditiveBlending });
            const particles = new THREE.Points(geometry, material);
            particles.userData.originalPositions = originalPositions;
            scene.add(particles);
            visualObjects.push({ points: particles });
        }

        function createWavesVisual() {
            clearVisuals();
            const planeGeometry = new THREE.PlaneGeometry(15, 15, 80, 80);
            const obj = createGeometricObject(planeGeometry, 0);
            obj.mesh.rotation.x = -Math.PI / 2;
            obj.wireframe.rotation.x = -Math.PI / 2;
            obj.points.rotation.x = -Math.PI / 2;
            visualObjects.push(obj);
        }

        function createCubesVisual() {
            clearVisuals();
            const numCubes = 15;
            for (let i = 0; i < numCubes; i++) {
                const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createAudioBarsVisual() {
            clearVisuals();
            const numBars = 64;
            const barWidth = 0.1;
            const barSpacing = 0.15;
            for (let i = 0; i < numBars; i++) {
                const geometry = new THREE.BoxGeometry(barWidth, 0.1, barWidth);
                const material = new THREE.MeshPhongMaterial({ color: getCustomColor(i), transparent: true, opacity: params.layerOpacity });
                const bar = new THREE.Mesh(geometry, material);
                bar.position.x = (i - numBars / 2) * barSpacing;
                bar.position.y = -2;
                scene.add(bar);
                visualObjects.push({ mesh: bar });
            }
        }

        function createTorusVisual() {
            clearVisuals();
            const numToruses = 8;
            for (let i = 0; i < numToruses; i++) {
                const geometry = new THREE.TorusGeometry(2, 0.8, 16, 100);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createTorusKnotVisual() {
            clearVisuals();
            const geometry = new THREE.TorusKnotGeometry(2.5, 0.8, 100, 16);
            const obj = createGeometricObject(geometry, 0);
            visualObjects.push(obj);
        }

        function createDodecahedronVisual() {
            clearVisuals();
            const numDodecahedrons = 5;
            for (let i = 0; i < numDodecahedrons; i++) {
                const geometry = new THREE.DodecahedronGeometry(2);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createIcosahedronVisual() {
            clearVisuals();
            const numIcosahedrons = 5;
            for (let i = 0; i < numIcosahedrons; i++) {
                const geometry = new THREE.IcosahedronGeometry(2);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createOctahedronVisual() {
            clearVisuals();
            const numOctahedrons = 5;
            for (let i = 0; i < numOctahedrons; i++) {
                const geometry = new THREE.OctahedronGeometry(2);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createConeVisual() {
            clearVisuals();
            const numCones = 7;
            for (let i = 0; i < numCones; i++) {
                const geometry = new THREE.ConeGeometry(1.5, 3, 32);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createCylinderVisual() {
            clearVisuals();
            const numCylinders = 7;
            for (let i = 0; i < numCylinders; i++) {
                const geometry = new THREE.CylinderGeometry(1, 1, 3, 32);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createRingVisual() {
            clearVisuals();
            const numRings = 10;
            for (let i = 0; i < numRings; i++) {
                const geometry = new THREE.RingGeometry(1, 2, 32);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createTetrahedronVisual() {
            clearVisuals();
            const numTetrahedrons = 5;
            for (let i = 0; i < numTetrahedrons; i++) {
                const geometry = new THREE.TetrahedronGeometry(2);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createMultiTorusVisual() {
            clearVisuals();
            const numToruses = 8;
            for (let i = 0; i < numToruses; i++) {
                const geometry = new THREE.TorusGeometry(1.5, 0.5, 10, 50);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.position.set((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8);
                obj.wireframe.position.copy(obj.mesh.position);
                obj.points.position.copy(obj.mesh.position);
                visualObjects.push(obj);
            }
        }

        function createGyroscope1Visual() {
            clearVisuals();
            const numRings = 5;
            for (let i = 0; i < numRings; i++) {
                const radius = 1 + i * 0.5;
                const geometry = new THREE.RingGeometry(radius - 0.1, radius + 0.1, 64);
                const obj = createGeometricObject(geometry, i);
                obj.mesh.rotation.x = Math.PI / 2;
                obj.wireframe.rotation.x = Math.PI / 2;
                obj.points.rotation.x = Math.PI / 2;
                visualObjects.push(obj);
            }
        }

        function createGyroscope2Visual() {
            clearVisuals();
            const numSpheres = 4;
            for (let i = 0; i < numSpheres; i++) {
                const radius = 0.8 + i * 0.6;
                const geometry = new THREE.SphereGeometry(radius, 32, 32);
                const obj = createGeometricObject(geometry, i);
                visualObjects.push(obj);
            }
        }

        function createGyroscope3Visual() {
            clearVisuals();
            const numToruses = 3;
            for (let i = 0; i < numToruses; i++) {
                const geometry = new THREE.TorusGeometry(2.5, 0.5, 16, 100);
                const obj = createGeometricObject(geometry, i);
                if (i === 0) obj.mesh.rotation.x = Math.PI / 2;
                if (i === 1) obj.mesh.rotation.y = Math.PI / 2;
                if (i === 2) obj.mesh.rotation.z = Math.PI / 2;
                obj.wireframe.rotation.copy(obj.mesh.rotation);
                obj.points.rotation.copy(obj.mesh.rotation);
                visualObjects.push(obj);
            }
        }

        const fractalNoiseVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fractalNoiseFragmentShader = `
            uniform float time;
            uniform float audioAmplitude;
            uniform float colorSpeed;
            uniform float deformationLevel;
            uniform float shapeScale;
            uniform vec3 customColor1;
            uniform vec3 customColor2;
            uniform vec3 customColor3;
            uniform bool grayscale;
            uniform float layerOpacity;
            varying vec2 vUv;
            float hash(float n) { return fract(sin(n) * 43758.5453123); }
            float noise2D(vec2 p) {
                vec2 ip = floor(p); vec2 fp = fract(p); fp = fp * fp * (3.0 - 2.0 * fp);
                float tl = hash(ip.x + ip.y * 57.0); float tr = hash(ip.x + 1.0 + ip.y * 57.0);
                float bl = hash(ip.x + (ip.y + 1.0) * 57.0); float br = hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0);
                return mix(mix(tl, tr, fp.x), mix(bl, br, fp.x), fp.y);
            }
            float fbm(vec2 p) {
                float sum = 0.0; float amp = 0.5; float freq = 1.0;
                for (int i = 0; i < 5; i++) {
                    sum += noise2D(p * freq) * amp; freq *= 2.0; amp *= 0.5;
                }
                return sum;
            }
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                uv *= shapeScale;
                uv += vec2(sin(time * 0.1), cos(time * 0.08)) * 0.5 * deformationLevel;
                float f = fbm(uv + time * colorSpeed * 0.5);
                f += fbm(uv * 2.0 + time * colorSpeed * 0.7) * 0.5;
                f += audioAmplitude * 0.5;
                vec3 color = mix(customColor1, customColor2, f);
                color = mix(color, customColor3, f * 0.5 + 0.5);
                if (grayscale) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    color = vec3(gray);
                }
                gl_FragColor = vec4(color, layerOpacity);
            }
        `;

        function createFractalNoiseVisual() {
            clearVisuals();
            const planeGeometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 }, audioAmplitude: { value: 0.0 }, colorSpeed: { value: params.colorSpeed },
                    deformationLevel: { value: params.deformationLevel }, shapeScale: { value: params.shapeScale },
                    customColor1: { value: new THREE.Color(params.customColors[0]) },
                    customColor2: { value: new THREE.Color(params.customColors[1]) },
                    customColor3: { value: new THREE.Color(params.customColors[2]) },
                    grayscale: { value: params.grayscale }, layerOpacity: { value: params.layerOpacity },
                },
                vertexShader: fractalNoiseVertexShader, fragmentShader: fractalNoiseFragmentShader,
                transparent: true, blending: THREE.AdditiveBlending,
            });
            const mesh = new THREE.Mesh(planeGeometry, material);
            mesh.position.z = -1;
            scene.add(mesh);
            visualObjects.push({ mesh: mesh, update: (delta, audioAmplitude) => {
                material.uniforms.time.value += delta;
                material.uniforms.audioAmplitude.value = audioAmplitude;
                material.uniforms.colorSpeed.value = params.colorSpeed;
                material.uniforms.deformationLevel.value = params.deformationLevel;
                material.uniforms.shapeScale.value = params.shapeScale;
                material.uniforms.customColor1.value.set(params.customColors[0]);
                material.uniforms.customColor2.value.set(params.customColors[1]);
                material.uniforms.customColor3.value.set(params.customColors[2]);
                material.uniforms.grayscale.value = params.grayscale;
                material.uniforms.layerOpacity.value = params.layerOpacity;
            }});
            onWindowResize();
        }

        const vertexShaderHydra = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const fragmentShaderHydraFuego = `
            uniform float time; uniform float audioAmplitude; uniform float shapeScale; uniform float colorSpeed;
            varying vec2 vUv;
            void main() {
                vec2 uv = vUv * 2.0 - 1.0; uv /= shapeScale;
                float r = length(uv); float angle = atan(uv.y, uv.x);
                float swirl = sin(r * 10.0 - time * 2.0 * colorSpeed + audioAmplitude * 5.0);
                float radial = cos(angle * 3.0 + time * colorSpeed) * 0.5 + 0.5;
                float flare = pow(1.0 - r, 3.0);
                vec3 color = vec3(
                    sin(time * colorSpeed + uv.x * 3.0) * 0.5 + 0.5,
                    cos(time * colorSpeed + uv.y * 3.0) * 0.5 + 0.5,
                    swirl * radial
                );
                color *= flare * (3.0 + audioAmplitude * 2.0);
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        const fragmentShaderHydraGlitch = `
            uniform float time; uniform float audioAmplitude; uniform float shapeScale; uniform float colorSpeed; uniform float deformationLevel;
            varying vec2 vUv;
            float hash(float n) { return fract(sin(n) * 43758.5453123); }
            float noise2D(vec2 p) {
                vec2 ip = floor(p); vec2 fp = fract(p); fp = fp * fp * (3.0 - 2.0 * fp);
                float tl = hash(ip.x + ip.y * 57.0); float tr = hash(ip.x + 1.0 + ip.y * 57.0);
                float bl = hash(ip.x + (ip.y + 1.0) * 57.0); float br = hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0);
                return mix(mix(tl, tr, fp.x), mix(bl, br, fp.x), fp.y);
            }
            void main() {
                vec2 uv = vUv * 2.0 - 1.0; uv /= shapeScale;
                vec2 glitchOffset = vec2(
                    sin(time * 10.0 + uv.y * 50.0) * 0.05 * audioAmplitude * deformationLevel,
                    cos(time * 12.0 + uv.x * 50.0) * 0.05 * audioAmplitude * deformationLevel
                );
                uv += glitchOffset;
                vec2 tiledUV = fract(uv * (5.0 + audioAmplitude * 2.0));
                float n = noise2D(uv * 10.0 + time * colorSpeed);
                vec3 color = vec3(
                    sin(time * colorSpeed + tiledUV.x * 10.0 + n) * 0.5 + 0.5,
                    cos(time * colorSpeed + tiledUV.y * 10.0 + n) * 0.5 + 0.5,
                    sin(time * colorSpeed * 0.7 + tiledUV.x * 5.0 + tiledUV.y * 5.0 + n) * 0.5 + 0.5
                );
                float fragmentEffect = step(0.5, fract(uv.x * 10.0 + uv.y * 10.0 + time));
                color = mix(color, vec3(1.0 - color), fragmentEffect * audioAmplitude);
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        const fragmentShaderHydraTunel = `
            uniform float time; uniform float audioAmplitude; uniform float shapeScale; uniform float colorSpeed; uniform float deformationLevel;
            varying vec2 vUv;
            void main() {
                vec2 uv = vUv * 2.0 - 1.0; uv /= shapeScale;
                float r = length(uv); float angle = atan(uv.y, uv.x);
                float tunnelSpeed = time * colorSpeed * 5.0;
                float tunnelDistortion = sin(r * 15.0 - tunnelSpeed + audioAmplitude * 10.0) * 0.1 * deformationLevel;
                r += tunnelDistortion;
                float stripes = fract(r * 5.0 - tunnelSpeed * 0.5); stripes = pow(stripes, 2.0);
                vec3 color = vec3(
                    sin(angle * 5.0 + time * colorSpeed) * 0.5 + 0.5,
                    cos(angle * 3.0 + time * colorSpeed * 0.7) * 0.5 + 0.5,
                    sin(angle * 7.0 + time * colorSpeed * 1.2) * 0.5 + 0.5
                );
                color = mix(color, vec3(stripes), 0.7);
                float glow = pow(1.0 - r, 5.0 + audioAmplitude * 5.0);
                color += vec3(glow);
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        function createHydraFuegoVisual() {
            clearVisuals();
            const geometry = new THREE.PlaneGeometry(2, 2);
            const uniforms = {
                time: { value: 0 }, audioAmplitude: { value: 0.0 }, shapeScale: { value: params.shapeScale }, colorSpeed: { value: params.colorSpeed }
            };
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShaderHydra, fragmentShader: fragmentShaderHydraFuego, uniforms: uniforms,
                depthWrite: false, depthTest: false, blending: THREE.AdditiveBlending, transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -1;
            scene.add(mesh);
            visualObjects.push({ mesh: mesh, update: (delta, audioAmplitude) => {
                material.uniforms.time.value += delta;
                material.uniforms.audioAmplitude.value = audioAmplitude;
                material.uniforms.shapeScale.value = params.shapeScale;
                material.uniforms.colorSpeed.value = params.colorSpeed;
            }});
            onWindowResize();
        }

        function createHydraGlitchVisual() {
            clearVisuals();
            const geometry = new THREE.PlaneGeometry(2, 2);
            const uniforms = {
                time: { value: 0 }, audioAmplitude: { value: 0.0 }, shapeScale: { value: params.shapeScale },
                colorSpeed: { value: params.colorSpeed }, deformationLevel: { value: params.deformationLevel }
            };
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShaderHydra, fragmentShader: fragmentShaderHydraGlitch, uniforms: uniforms,
                depthWrite: false, depthTest: false, blending: THREE.AdditiveBlending, transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -1;
            scene.add(mesh);
            visualObjects.push({ mesh: mesh, update: (delta, audioAmplitude) => {
                material.uniforms.time.value += delta;
                material.uniforms.audioAmplitude.value = audioAmplitude;
                material.uniforms.shapeScale.value = params.shapeScale;
                material.uniforms.colorSpeed.value = params.colorSpeed;
                material.uniforms.deformationLevel.value = params.deformationLevel;
            }});
            onWindowResize();
        }

        function createHydraTunelVisual() {
            clearVisuals();
            const geometry = new THREE.PlaneGeometry(2, 2);
            const uniforms = {
                time: { value: 0 }, audioAmplitude: { value: 0.0 }, shapeScale: { value: params.shapeScale },
                colorSpeed: { value: params.colorSpeed }, deformationLevel: { value: params.deformationLevel }
            };
            const material = new THREE.ShaderMaterial({
                vertexShader: vertexShaderHydra, fragmentShader: fragmentShaderHydraTunel, uniforms: uniforms,
                depthWrite: false, depthTest: false, blending: THREE.AdditiveBlending, transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.z = -1;
            scene.add(mesh);
            visualObjects.push({ mesh: mesh, update: (delta, audioAmplitude) => {
                material.uniforms.time.value += delta;
                material.uniforms.audioAmplitude.value = audioAmplitude;
                material.uniforms.shapeScale.value = params.shapeScale;
                material.uniforms.colorSpeed.value = params.colorSpeed;
                material.uniforms.deformationLevel.value = params.deformationLevel;
            }});
            onWindowResize();
        }

        function switchVisualMode(mode) {
            clearVisuals();
            currentVisualMode = mode;
            switch (mode) {
                case 'spheres': createSpheresVisual(); break;
                case 'particles': createParticlesVisual(); break;
                case 'waves': createWavesVisual(); break;
                case 'cubes': createCubesVisual(); break;
                case 'audioBars': createAudioBarsVisual(); break;
                case 'torus': createTorusVisual(); break;
                case 'torusKnot': createTorusKnotVisual(); break;
                case 'dodecahedron': createDodecahedronVisual(); break;
                case 'icosahedron': createIcosahedronVisual(); break;
                case 'octahedron': createOctahedronVisual(); break;
                case 'cone': createConeVisual(); break;
                case 'cylinder': createCylinderVisual(); break;
                case 'ring': createRingVisual(); break;
                case 'tetrahedron': createTetrahedronVisual(); break;
                case 'multiTorus': createMultiTorusVisual(); break;
                case 'gyroscope1': createGyroscope1Visual(); break;
                case 'gyroscope2': createGyroscope2Visual(); break;
                case 'gyroscope3': createGyroscope3Visual(); break;
                case 'fractalNoise': createFractalNoiseVisual(); break;
                case 'hydraFuego': createHydraFuegoVisual(); break;
                case 'hydraGlitch': createHydraGlitchVisual(); break;
                case 'hydraTunel': createHydraTunelVisual(); break;
            }
            visualObjects.forEach(obj => {
                if (obj.mesh && obj.wireframe && obj.points) {
                    updateMaterialMode(obj, params.materialMode);
                }
            });
        }

        function createParticleBurst(position, color, scale = 1.0) {
            const burstGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const burstMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending });
            const burstParticle = new THREE.Mesh(burstGeometry, burstMaterial);
            burstParticle.position.copy(position);
            burstParticle.scale.set(scale, scale, scale);
            scene.add(burstParticle);
            let opacity = 1.0;
            let currentScale = scale;
            const animateBurst = () => {
                if (opacity > 0) {
                    opacity -= 0.05;
                    currentScale += 0.05;
                    burstParticle.material.opacity = opacity;
                    burstParticle.scale.set(currentScale, currentScale, currentScale);
                    requestAnimationFrame(animateBurst);
                } else {
                    burstParticle.geometry.dispose();
                    burstParticle.material.dispose();
                    scene.remove(burstParticle);
                }
            };
            animateBurst();
        }

        function clearAllBackgroundPlanes() {
            stopImageCarousel();
            loadedImageTextures.forEach(tex => tex.dispose());
            loadedImageTextures = [];
            currentImageIndex = -1;
            stopCameraAsBackground();
            if (imagePlane) {
                if (imagePlane.material.uniforms.backgroundTexture.value) {
                    imagePlane.material.uniforms.backgroundTexture.value.dispose();
                }
                imagePlane.material.uniforms.backgroundTexture.value = null;
                imagePlane.visible = false;
            }
        }

        async function setupAudio(deviceId = null) {
            if (audioContext) {
                if (audioContext.state !== 'closed') {
                    await audioContext.close();
                }
            }
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                const constraints = { audio: { deviceId: deviceId ? { exact: deviceId } : undefined } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                toggleAudioBtn.textContent = 'desactivar audio';
                audioDebugInfo.style.display = 'block';
                showMessage('¡audio activado! el micrófono está escuchando la onda.');
            } catch (err) {
                console.error('error al acceder al micrófono:', err);
                let userMessage = '¡ay, carnal! no pude acceder al micrófono. ';
                if (err.name === 'NotAllowedError') {
                    userMessage += 'parece que los permisos fueron denegados por tu navegador. por favor, revisa la configuración de tu navegador para permitir el acceso al micrófono.';
                } else if (err.name === 'NotFoundError') {
                    userMessage += 'no se encontró ningún micrófono. asegúrate de que uno esté conectado y funcionando.';
                } else if (err.message && err.message.includes('Permission denied by system')) {
                    userMessage += '¡permiso denegado por el sistema! para activar el audio, necesitas ir a la configuración de privacidad y seguridad de tu sistema operativo y navegador y permitir el acceso al micrófono.';
                } else {
                    userMessage += `error: ${err.message}. checa los permisos de tu navegador.`;
                }
                showMessage(userMessage);
                toggleAudioBtn.textContent = 'activar audio';
                if (audioContext && audioContext.state !== 'closed') {
                    audioContext.close();
                }
                audioContext = null; analyser = null; microphone = null; dataArray = null;
            }
        }

        function stopAudio() {
            if (audioContext) {
                if (microphone && microphone.mediaStream) {
                    microphone.mediaStream.getTracks().forEach(track => track.stop());
                }
                audioContext.close();
                audioContext = null; analyser = null; microphone = null; dataArray = null;
                toggleAudioBtn.textContent = 'activar audio';
                audioDebugInfo.style.display = 'none';
            }
        }

        function loadImageAsBackground(event) {
            const files = event.target.files;
            if (files.length > 0) {
                clearAllBackgroundPlanes();
                loadedImageTextures.forEach(tex => tex.dispose());
                loadedImageTextures = [];
                currentImageIndex = -1;
                stopImageCarousel();
                const textureLoader = new THREE.TextureLoader();
                let loadedCount = 0;
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        textureLoader.load(e.target.result, function(texture) {
                            loadedImageTextures.push(texture);
                            loadedCount++;
                            if (loadedCount === files.length) {
                                showMessage(`¡${loadedCount} imagen(es) de fondo cargada(s) con éxito!`);
                                currentImageIndex = 0;
                                updateImagePlaneTexture(loadedImageTextures[currentImageIndex], false);
                                if (loadedImageTextures.length > 1) {
                                    startImageCarousel();
                                }
                            }
                        }, undefined, function(err) {
                            console.error('error loading texture:', err);
                            showMessage('¡ups! hubo un error al cargar una imagen. intenta con otra.');
                        });
                    };
                    reader.readAsDataURL(file);
                }
            } else {
                console.log('no image file selected.');
            }
        }

        function updateImagePlaneTexture(texture, isCameraSource) {
            if (imagePlane) {
                if (imagePlane.material.uniforms.backgroundTexture.value && imagePlane.material.uniforms.backgroundTexture.value !== texture) {
                    imagePlane.material.uniforms.backgroundTexture.value.dispose();
                }
                imagePlane.material.uniforms.backgroundTexture.value = texture;
                imagePlane.material.uniforms.isCameraActive.value = isCameraSource;
                isCameraActive = isCameraSource;
                imagePlane.visible = true;
                onWindowResize();
            }
        }

        function startImageCarousel() {
            stopImageCarousel();
            if (loadedImageTextures.length > 1) {
                imageChangeInterval = setInterval(() => {
                    currentImageIndex = (currentImageIndex + 1) % loadedImageTextures.length;
                    updateImagePlaneTexture(loadedImageTextures[currentImageIndex], false);
                }, IMAGE_CHANGE_INTERVAL_MS);
            }
        }

        function stopImageCarousel() {
            if (imageChangeInterval) {
                clearInterval(imageChangeInterval);
                imageChangeInterval = null;
            }
        }

        function clearBackgroundImage() {
            stopImageCarousel();
            loadedImageTextures.forEach(tex => tex.dispose());
            loadedImageTextures = [];
            currentImageIndex = -1;
            stopCameraAsBackground();
            if (imagePlane) {
                if (imagePlane.material.uniforms.backgroundTexture.value) {
                    imagePlane.material.uniforms.backgroundTexture.value.dispose();
                }
                imagePlane.material.uniforms.backgroundTexture.value = null;
                imagePlane.visible = false;
            }
            showMessage('imagen de fondo borrada. ¡campo libre!');
        }

        async function startCameraAsBackground(deviceId) {
            if (currentCameraStream) {
                currentCameraStream.getTracks().forEach(track => track.stop());
                currentCameraStream = null;
            }
            try {
                const constraints = { video: { deviceId: deviceId ? { exact: deviceId } : undefined } };
                currentCameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoFeed.srcObject = currentCameraStream;
                videoFeed.onloadedmetadata = () => {
                    videoFeed.play().catch(e => console.error("Error playing video:", e));
                    videoTexture = new THREE.VideoTexture(videoFeed);
                    videoTexture.minFilter = THREE.LinearFilter;
                    videoTexture.magFilter = THREE.LinearFilter;
                    videoTexture.format = THREE.RGBAFormat;
                    updateImagePlaneTexture(videoTexture, true);
                };
                showMessage('¡cámara activada como fondo!');
                startCameraBtn.disabled = true;
                stopCameraBtn.disabled = false;
            } catch (err) {
                console.error('error al iniciar la cámara:', err);
                let message = '¡falló la cámara! ';
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    message += 'necesitas darle permiso a la cámara en tu navegador.';
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    message += 'no se encontró la cámara. asegúrate de que esté conectada.';
                } else {
                    message += `error: ${err.name} - ${err.message}`;
                }
                showMessage(message);
                cameraSelect.value = "";
                stopCameraAsBackground();
            }
        }

        function stopCameraAsBackground() {
            if (currentCameraStream) {
                currentCameraStream.getTracks().forEach(track => track.stop());
                currentCameraStream = null;
                videoFeed.srcObject = null;
                if (videoTexture) {
                    videoTexture.dispose();
                    videoTexture = null;
                }
                if (imagePlane && imagePlane.material.uniforms.backgroundTexture.value) {
                    if (imagePlane.material.uniforms.backgroundTexture.value === videoTexture) {
                        imagePlane.material.uniforms.backgroundTexture.value = null;
                    }
                    imagePlane.material.uniforms.isCameraActive.value = false;
                    isCameraActive = false;
                    imagePlane.visible = false;
                }
                showMessage('cámara de fondo detenida.');
            }
            startCameraBtn.disabled = false;
            stopCameraBtn.disabled = true;
        }


        // --- Main Visualizer Animation Loop ---
        let lastTime = 0;
        function animateMainVisualizer(time) {
            const delta = (time - lastTime) * 0.001;
            lastTime = time;
            let averageAmplitude = 0;
            let normalizedReaction = 0;
            let bassAmplitude = 0;
            let midAmplitude = 0;
            let trebleAmplitude = 0;
            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray);
                averageAmplitude = dataArray.reduce((sum, val) => sum + val, 0) / dataArray.length;
                const bufferLength = analyser.frequencyBinCount;
                const bassRange = Math.floor(bufferLength * 0.2);
                const midRange = Math.floor(bufferLength * 0.5);
                for (let i = 0; i < bufferLength; i++) {
                    if (i < bassRange) {
                        bassAmplitude += dataArray[i];
                    } else if (i < midRange) {
                        midAmplitude += dataArray[i];
                    } else {
                        trebleAmplitude += dataArray[i];
                    }
                }
                bassAmplitude /= bassRange;
                midAmplitude /= (midRange - bassRange);
                trebleAmplitude /= (bufferLength - midRange);
                const normalizeBand = (amplitude, sensitivity) => {
                    if (amplitude > params.audioReactionThreshold) {
                        let normalized = (amplitude - params.audioReactionThreshold) / (255 - params.audioReactionThreshold);
                        return Math.max(0, Math.min(1, normalized)) * sensitivity;
                    }
                    return 0;
                };
                const normalizedBass = normalizeBand(bassAmplitude, params.bassSensitivity);
                const normalizedMid = normalizeBand(midAmplitude, params.midSensitivity);
                const normalizedTreble = normalizeBand(trebleAmplitude, params.trebleSensitivity);
                normalizedReaction = normalizeBand(averageAmplitude, params.amplitudeSensitivity);
                currentAmplitudeSpan.textContent = averageAmplitude.toFixed(0);
                normalizedReactionSpan.textContent = normalizedReaction.toFixed(2);
                bassAmplitudeSpan.textContent = normalizedBass.toFixed(2);
                midAmplitudeSpan.textContent = normalizedMid.toFixed(2);
                trebleAmplitudeSpan.textContent = trebleAmplitude.toFixed(2);
                switch (currentVisualMode) {
                    case 'spheres': case 'waves': case 'cubes': case 'torus': case 'torusKnot': case 'dodecahedron': case 'icosahedron': case 'octahedron': case 'cone': case 'cylinder': case 'ring': case 'tetrahedron': case 'multiTorus': case 'gyroscope1': case 'gyroscope2': case 'gyroscope3':
                        visualObjects.forEach((obj) => {
                            if (obj.mesh) {
                                obj.mesh.rotation.x += 0.005 + normalizedReaction * 0.01;
                                obj.mesh.rotation.y += 0.005 + normalizedReaction * 0.01;
                                obj.mesh.rotation.z += 0.005 + normalizedReaction * 0.01;
                                if (obj.wireframe) obj.wireframe.rotation.copy(obj.mesh.rotation);
                                if (obj.points) obj.points.rotation.copy(obj.mesh.rotation);
                                const scale = params.shapeScale * (1 + normalizedBass * 0.8);
                                obj.mesh.scale.set(scale, scale, scale);
                                if (obj.wireframe) obj.wireframe.scale.copy(obj.mesh.scale);
                                if (obj.points) obj.points.scale.copy(obj.mesh.scale);
                                if (currentVisualMode !== 'torusKnot' && currentVisualMode !== 'audioBars' && obj.mesh.geometry.userData.originalPositions) {
                                    applyDeformation(obj, normalizedTreble, params.deformationLevel);
                                }
                                obj.mesh.material.opacity = params.layerOpacity;
                                const colorIndex = obj.index + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                applyMaterialColor(obj.mesh.material, colorIndex);
                            }
                            if (obj.wireframe) {
                                obj.wireframe.material.opacity = params.layerOpacity;
                                const colorIndex = obj.index + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                applyMaterialColor(obj.wireframe.material, colorIndex);
                            }
                            if (obj.points) {
                                obj.points.material.opacity = params.layerOpacity;
                                const colorIndex = obj.index + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                applyMaterialColor(obj.points.material, colorIndex);
                                obj.points.material.size = 0.1 + normalizedTreble * params.amplitudeSensitivity * 0.5;
                            }
                        });
                        break;
                    case 'particles':
                        const particles = visualObjects[0].points;
                        if (particles) {
                            const positions = particles.geometry.attributes.position.array;
                            const colors = particles.geometry.attributes.color.array;
                            const originalPositions = particles.userData.originalPositions;
                            const colorTemp = new THREE.Color();
                            for (let i = 0; i < particles.geometry.attributes.position.count; i++) {
                                positions[i * 3 + 1] = originalPositions[i * 3 + 1] + (Math.sin(performance.now() * 0.002 + i / 100) * normalizedBass * 5) * params.shapeScale * params.deformationLevel;
                                const colorIndex = i + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                colorTemp.copy(getCustomColor(colorIndex));
                                colors[i * 3] = colorTemp.r;
                                colors[i * 3 + 1] = colorTemp.g;
                                colors[i * 3 + 2] = colorTemp.b;
                            }
                            particles.geometry.attributes.position.needsUpdate = true;
                            particles.geometry.attributes.color.needsUpdate = true;
                            particles.material.opacity = params.layerOpacity;
                            particles.material.size = 0.1 + normalizedTreble * params.amplitudeSensitivity * 0.5;
                        }
                        break;
                    case 'audioBars':
                        if (dataArray && visualObjects.length > 0) {
                            const numBars = visualObjects.length;
                            for (let i = 0; i < numBars; i++) {
                                const bar = visualObjects[i].mesh;
                                const barHeight = (dataArray[i] / 255 * 5 * params.amplitudeSensitivity * params.shapeScale) * (1 + normalizedBass * 0.5) + normalizedTreble * 2;
                                bar.scale.y = barHeight;
                                bar.position.y = -2 + barHeight / 2;
                                const colorIndex = i + Math.floor(performance.now() * params.colorSpeed * normalizedMid * 5);
                                applyMaterialColor(bar.material, colorIndex);
                                bar.material.opacity = params.layerOpacity;
                            }
                        }
                        break;
                    case 'fractalNoise': case 'hydraFuego': case 'hydraGlitch': case 'hydraTunel':
                        const shaderMesh = visualObjects[0];
                        if (shaderMesh && shaderMesh.update) {
                            shaderMesh.update(delta, normalizedReaction);
                        }
                        break;
                }
                if (normalizedReaction > 0.9 && visualObjects.length > 0) {
                    const burstColor = getCustomColor(Math.floor(Math.random() * params.customColors.length));
                    createParticleBurst(new THREE.Vector3(0, 0, 0), burstColor, normalizedReaction * 2);
                }
            }
            if (imagePlane && imagePlane.visible && imagePlane.material.uniforms.backgroundTexture.value) {
                imagePlane.material.uniforms.isCameraActive.value = isCameraActive;
                imagePlane.material.uniforms.chromaKeyColor.value.set(params.chromaKeyColor);
                imagePlane.material.uniforms.chromaKeyThreshold.value = params.chromaKeyThreshold;
                imagePlane.material.uniforms.backgroundFilterMode.value = isCameraActive ? params.cameraFilterMode : 0;
                imagePlane.material.uniforms.backgroundNoiseAmount.value = isCameraActive ? params.cameraNoiseAmount : 0;
                imagePlane.material.uniforms.backgroundEdgeSensitivity.value = isCameraActive ? params.cameraEdgeSensitivity : 0;
                imagePlane.material.uniforms.backgroundBrightness.value = isCameraActive ? params.cameraBrightness : 0;
                imagePlane.material.uniforms.backgroundContrast.value = isCameraActive ? params.cameraContrast : 1;
                imagePlane.material.uniforms.backgroundPixelateSize.value = isCameraActive ? params.cameraPixelateSize : 1;
                imagePlane.material.uniforms.backgroundBlurAmount.value = isCameraActive ? params.cameraBlurAmount : 0;
                imagePlane.material.uniforms.backgroundMaterialColor.value.copy(isCameraActive ? params.cameraMaterialColor : backgroundMaterialColors.none);
                imagePlane.material.uniforms.uHueRotate.value = params.hueRotate * Math.PI / 180.0;
                imagePlane.material.uniforms.uSaturation.value = params.saturation / 100.0;
                imagePlane.material.uniforms.uVignette.value = params.vignette / 100.0;
                imagePlane.material.uniforms.uPosterizeLevels.value = params.posterize;
                imagePlane.material.uniforms.uSharpenAmount.value = params.sharpen;
                imagePlane.material.uniforms.uScanlineDensity.value = params.scanline / 100.0;
                imagePlane.material.uniforms.audioVolume.value = normalizedReaction;
                imagePlane.material.uniforms.time.value = performance.now() * 0.001;
            }
            renderer.render(scene, camera);
        }

        // --- MIDI Functions ---
        async function initMidi() {
            if (!navigator.requestMIDIAccess) {
                showMessage('¡híjole! tu navegador no soporta la api web midi o está deshabilitada por la política de permisos de tu navegador o sistema. no podrás usar controles midi.');
                midiInputSelect.disabled = true; midiOutputSelect.disabled = true; midiChannelInput.disabled = true;
                startMidiLearnBtn.disabled = true; stopMidiLearnBtn.disabled = true; clearMidiMappingsBtn.disabled = true;
                midiMonitor.textContent = 'la api web midi no está disponible o está bloqueada.'; return;
            }
            try {
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                midiAccess.onstatechange = onMidiStateChange;
                updateMidiDevices();
            } catch (err) {
                console.error('error al acceder a midi:', err);
                showMessage('¡ay, carnal! no pude acceder a midi. esto suele pasar si los permisos están denegados por tu navegador o sistema operativo. revisa la configuración de permisos de midi.');
                midiInputSelect.disabled = true; midiOutputSelect.disabled = true; midiChannelInput.disabled = true;
                startMidiLearnBtn.disabled = true; stopMidiLearnBtn.disabled = true; clearMidiMappingsBtn.disabled = true;
                midiMonitor.textContent = 'acceso a midi denegado. revisa los permisos.';
            }
        }

        function onMidiStateChange(event) {
            console.log(`midi device state change: ${event.port.name} ${event.port.state}`);
            updateMidiDevices();
        }

        function updateMidiDevices() {
            midiInputs = midiAccess.inputs;
            midiOutputs = midiAccess.outputs;
            midiInputSelect.innerHTML = '<option value="">-- selecciona entrada --</option>';
            midiInputs.forEach(input => {
                const option = document.createElement('option');
                option.value = input.id; option.textContent = input.name;
                midiInputSelect.appendChild(option);
            });
            midiOutputSelect.innerHTML = '<option value="">-- selecciona salida --</option>';
            midiOutputs.forEach(output => {
                const option = document.createElement('option');
                option.value = output.id; option.textContent = output.name;
                midiOutputSelect.appendChild(option);
            });
            if (selectedMidiInput && midiInputs.has(selectedMidiInput.id)) {
                midiInputSelect.value = selectedMidiInput.id;
            } else {
                selectedMidiInput = null;
            }
        }

        function onMidiMessage(event) {
            const data = event.data;
            const status = data[0]; const type = status & 0xF0; const channel = (status & 0x0F) + 1;
            const data1 = data[1]; const data2 = data[2];
            const midiMessageString = `status: ${status.toString(16)}, type: ${type.toString(16)}, channel: ${channel}, data1: ${data1}, data2: ${data2}`;
            midiMonitor.textContent += midiMessageString + '\n';
            midiMonitor.scrollTop = midiMonitor.scrollHeight;
            if (isLearningMidi && learnTargetElement && channel === selectedMidiChannel) {
                let midiTypeString = ''; let targetProperty = learnTargetElement.dataset.midiTarget;
                let minVal, maxVal, step;
                if (type === 0x90) { midiTypeString = 'note on'; if (learnTargetElement.tagName === 'BUTTON' || learnTargetElement.type === 'checkbox') { minVal = 0; maxVal = 1; step = 1; } else if (learnTargetElement.type === 'range') { minVal = parseFloat(learnTargetElement.min); maxVal = parseFloat(learnTargetElement.max); step = parseFloat(learnTargetElement.step); } else if (learnTargetElement.tagName === 'SELECT') { minVal = 0; maxVal = learnTargetElement.options.length - 1; step = 1; } else if (learnTargetElement.type === 'color') { minVal = 0; maxVal = 255; step = 1; }
                } else if (type === 0x80) { midiTypeString = 'note off'; if (learnTargetElement.tagName === 'BUTTON' || learnTargetElement.type === 'checkbox') { minVal = 0; maxVal = 1; step = 1; }
                } else if (type === 0xB0) { midiTypeString = 'control change'; if (learnTargetElement.type === 'range') { minVal = parseFloat(learnTargetElement.min); maxVal = parseFloat(learnTargetElement.max); step = parseFloat(learnTargetElement.step); } else if (targetElement.tagName === 'SELECT') { minVal = 0; maxVal = learnTargetElement.options.length - 1; step = 1; } else if (targetElement.tagName === 'BUTTON' || targetElement.type === 'checkbox') { minVal = 0; maxVal = 1; step = 1; } else if (targetElement.type === 'color') { minVal = 0; maxVal = 255; step = 1; }
                } else { return; }
                const newMapping = { midiType: midiTypeString, midiChannel: channel, midiNumber: data1, targetElementId: learnTargetElement.id, targetProperty: targetProperty, minVal: minVal, maxVal: maxVal, step: step, elementTag: learnTargetElement.tagName, elementType: learnTargetElement.type };
                const existingIndex = midiMappings.findIndex(m => m.midiType === newMapping.midiType && m.midiChannel === newMapping.midiChannel && m.midiNumber === newMapping.midiNumber && m.targetElementId === newMapping.targetElementId);
                if (existingIndex !== -1) {
                    midiMappings[existingIndex] = newMapping;
                    showMessage(`¡mapeo actualizado para ${learnTargetElement.id}!`);
                } else {
                    midiMappings.push(newMapping);
                    showMessage(`¡mapeo creado: ${learnTargetElement.id} con midi ${midiTypeString} ${data1} en canal ${channel}!`);
                }
                stopMidiLearn();
                renderMidiMappings();
                return;
            }
            midiMappings.forEach(mapping => {
                if (mapping.midiChannel === channel && mapping.midiNumber === data1) {
                    const targetElement = document.getElementById(mapping.targetElementId);
                    if (!targetElement) return;
                    if (mapping.midiType === 'control change' && type === 0xB0) {
                        const normalizedValue = data2 / 127;
                        const mappedValue = mapping.minVal + (normalizedValue * (mapping.maxVal - mapping.minVal));
                        if (targetElement.type === 'range') {
                            targetElement.value = mappedValue;
                            targetElement.dispatchEvent(new Event('input'));
                        } else if (targetElement.tagName === 'SELECT') {
                            const optionIndex = Math.round(normalizedValue * (mapping.maxVal - mapping.minVal));
                            targetElement.value = targetElement.options[optionIndex].value;
                            targetElement.dispatchEvent(new Event('change'));
                        } else if (targetElement.type === 'color') {
                            const colorValue = Math.round(normalizedValue * 255);
                            let currentColor = new THREE.Color(targetElement.value);
                            currentColor.r = colorValue / 255;
                            targetElement.value = '#' + currentColor.getHexString();
                            targetElement.dispatchEvent(new Event('input'));
                        }
                    } else if (mapping.midiType === 'note on' && type === 0x90 && data2 > 0) {
                        if (targetElement.tagName === 'BUTTON') {
                            targetElement.click();
                        } else if (targetElement.type === 'checkbox') {
                            targetElement.checked = !targetElement.checked;
                            targetElement.dispatchEvent(new Event('change'));
                        } else if (targetElement.type === 'range') {
                            const normalizedValue = data2 / 127;
                            const mappedValue = mapping.minVal + (normalizedValue * (mapping.maxVal - mapping.minVal));
                            targetElement.value = mappedValue;
                            targetElement.dispatchEvent(new Event('input'));
                        } else if (targetElement.type === 'color') {
                            const colorValue = Math.round(data2 / 127 * 255);
                            let currentColor = new THREE.Color(targetElement.value);
                            currentColor.g = colorValue / 255;
                            targetElement.value = '#' + currentColor.getHexString();
                            targetElement.dispatchEvent(new Event('input'));
                        }
                        const noteNumber = data1; const velocity = data2;
                        if (noteNumber >= 60 && noteNumber <= 71) {
                            params.colorSpeed = 0.01 + (velocity / 127) * 0.49;
                        } else if (noteNumber >= 72 && noteNumber <= 83) {
                            params.shapeScale = 0.1 + (velocity / 127) * 1.9;
                        }
                    } else if (mapping.midiType === 'note off' && type === 0x80) {
                        if (targetElement.type === 'checkbox') {
                            targetElement.checked = !targetElement.checked;
                            targetElement.dispatchEvent(new Event('change'));
                        }
                    }
                }
            });
        }

        function renderMidiMappings() {
            midiMappingsTableBody.innerHTML = '';
            const displayMappings = midiMappings.slice(0, 16);
            displayMappings.forEach((mapping, index) => {
                const row = midiMappingsTableBody.insertRow();
                row.insertCell().textContent = mapping.midiType;
                row.insertCell().textContent = mapping.midiChannel;
                row.insertCell().textContent = mapping.midiNumber;
                row.insertCell().textContent = mapping.targetElementId;
                const actionCell = row.insertCell();
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'borrar';
                deleteBtn.className = 'btn';
                deleteBtn.onclick = () => {
                    midiMappings.splice(midiMappings.indexOf(mapping), 1);
                    renderMidiMappings();
                    showMessage('mapeo borrado.');
                };
                actionCell.appendChild(deleteBtn);
            });
            if (midiMappings.length > 16) {
                const row = midiMappingsTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 5;
                cell.textContent = `... y ${midiMappings.length - 16} mapeos más (muestra limitada a 16)`;
                cell.style.textAlign = 'center'; cell.style.fontStyle = 'italic'; cell.style.color = '#a0aec0';
            }
        }

        function startMidiLearn() {
            isLearningMidi = true;
            midiLearnStatus.textContent = '¡modo de aprendizaje activado! haz clic en un control visual para mapearlo.';
            midiLearnStatus.classList.add('active');
            startMidiLearnBtn.style.display = 'none';
            stopMidiLearnBtn.style.display = 'block';
            document.body.classList.add('learn-mode-active');
            mappableControls.forEach(control => {
                control.removeEventListener('click', handleMappableControlClick);
                control.addEventListener('click', handleMappableControlClick, { once: true });
            });
        }

        function handleMappableControlClick(event) {
            if (isLearningMidi) {
                learnTargetElement = event.currentTarget;
                midiLearnStatus.textContent = `control seleccionado: "${learnTargetElement.id}". ahora envía un mensaje midi desde tu controlador.`;
                mappableControls.forEach(control => {
                    if (control !== learnTargetElement) {
                        control.removeEventListener('click', handleMappableControlClick);
                    }
                });
            }
        }

        function stopMidiLearn() {
            isLearningMidi = false;
            learnTargetElement = null;
            midiLearnStatus.textContent = '';
            midiLearnStatus.classList.remove('active');
            startMidiLearnBtn.style.display = 'block';
            stopMidiLearnBtn.style.display = 'none';
            document.body.classList.remove('learn-mode-active');
            mappableControls.forEach(control => {
                control.removeEventListener('click', handleMappableControlClick);
            });
        }

        function clearAllMidiMappings() {
            midiMappings = [];
            renderMidiMappings();
            showMessage('¡todos los mapeos midi borrados!');
        }

        async function enumerateMediaDevices() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                showMessage('¡híjole! tu navegador no soporta la enumeración de dispositivos multimedia (micrófono/cámara) o está deshabilitada por la política de permisos. no podrás seleccionar dispositivos de entrada.');
                audioInputSelect.disabled = true; cameraSelect.disabled = true; return;
            }
            try {
                await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                audioInputSelect.innerHTML = '<option value="">-- selecciona entrada de audio --</option>';
                cameraSelect.innerHTML = '<option value="">-- selecciona cámara --</option>';
                devices.forEach(device => {
                    if (device.kind === 'audioinput') {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `micrófono ${audioInputSelect.options.length + 1}`;
                        audioInputSelect.appendChild(option);
                    } else if (device.kind === 'videoinput') {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `cámara ${cameraSelect.options.length + 1}`;
                        cameraSelect.appendChild(option);
                    }
                });
            } catch (err) {
                console.error('error al enumerar dispositivos multimedia:', err);
                showMessage('¡híjole! no pude enumerar los dispositivos de audio/cámara. esto suele pasar si los permisos están denegados por tu navegador o sistema operativo. revisa la configuración de permisos.');
                audioInputSelect.disabled = true; cameraSelect.disabled = true; toggleAudioBtn.disabled = true;
                startCameraBtn.disabled = true; stopCameraBtn.disabled = true;
            }
        }

        sidebarToggleLeft.addEventListener('click', () => {
            leftSidebarContainer.classList.toggle('hidden');
            leftSidebarContainer.classList.toggle('active');
            if (rightSidebarContainer.classList.contains('active')) {
                rightSidebarContainer.classList.add('hidden');
                rightSidebarContainer.classList.remove('active');
            }
        });

        sidebarToggleRight.addEventListener('click', () => {
            rightSidebarContainer.classList.toggle('hidden');
            rightSidebarContainer.classList.toggle('active');
            if (leftSidebarContainer.classList.contains('active')) {
                leftSidebarContainer.classList.add('hidden');
                leftSidebarContainer.classList.remove('active');
            }
        });

        // Event Listeners for Main Visualizer
        visualModeSelect.addEventListener('change', (e) => switchVisualMode(e.target.value));
        colorSpeedSlider.addEventListener('input', (e) => params.colorSpeed = parseFloat(e.target.value));
        amplitudeSensitivitySlider.addEventListener('input', (e) => params.amplitudeSensitivity = parseFloat(e.target.value));
        audioReactionThresholdSlider.addEventListener('input', (e) => params.audioReactionThreshold = parseInt(e.target.value));
        bassSensitivitySlider.addEventListener('input', (e) => params.bassSensitivity = parseFloat(e.target.value));
        midSensitivitySlider.addEventListener('input', (e) => params.midSensitivity = parseFloat(e.target.value));
        trebleSensitivitySlider.addEventListener('input', (e) => params.trebleSensitivity = parseFloat(e.target.value));
        layerOpacitySlider.addEventListener('input', (e) => params.layerOpacity = parseFloat(e.target.value));
        shapeScaleSlider.addEventListener('input', (e) => params.shapeScale = parseFloat(e.target.value));
        deformationLevelSlider.addEventListener('input', (e) => params.deformationLevel = parseFloat(e.target.value));
        materialModeSlider.addEventListener('input', (e) => {
            params.materialMode = parseInt(e.target.value);
            visualObjects.forEach(obj => {
                if (obj.mesh && obj.wireframe && obj.points) {
                    updateMaterialMode(obj, params.materialMode);
                }
            });
        });
        chromaKeyColorInput.addEventListener('input', (e) => {
            params.chromaKeyColor = e.target.value;
        });
        chromaKeyThresholdSlider.addEventListener('input', (e) => {
            params.chromaKeyThreshold = parseFloat(e.target.value);
        });
        backgroundScaleSlider.addEventListener('input', (e) => {
            params.backgroundScaleFactor = parseFloat(e.target.value);
            onWindowResize();
        });
        hueRotateSlider.addEventListener('input', (e) => {
            params.hueRotate = parseFloat(e.target.value);
        });
        saturationSlider.addEventListener('input', (e) => {
            params.saturation = parseFloat(e.target.value);
        });
        vignetteSlider.addEventListener('input', (e) => {
            params.vignette = parseFloat(e.target.value);
        });
        posterizeSlider.addEventListener('input', (e) => {
            params.posterize = parseFloat(e.target.value);
        });
        sharpenSlider.addEventListener('input', (e) => {
            params.sharpen = parseFloat(e.target.value);
        });
        scanlineSlider.addEventListener('input', (e) => {
            params.scanline = parseFloat(e.target.value);
        });
        startCameraBtn.addEventListener('click', () => {
            const deviceId = cameraSelect.value;
            if (deviceId) {
                startCameraAsBackground(deviceId);
            } else {
                showMessage('¡Selecciona una cámara primero, carnal!');
            }
        });
        stopCameraBtn.addEventListener('click', stopCameraAsBackground);
        cameraFilterModeSelect.addEventListener('change', (e) => {
            params.cameraFilterMode = parseInt(e.target.value);
        });
        cameraNoiseSlider.addEventListener('input', (e) => {
            params.cameraNoiseAmount = parseFloat(e.target.value) / 100.0;
        });
        cameraEdgeSensitivitySlider.addEventListener('input', (e) => {
            params.cameraEdgeSensitivity = parseFloat(e.target.value) / 100.0;
        });
        cameraBrightnessSlider.addEventListener('input', (e) => {
            params.cameraBrightness = parseFloat(e.target.value) / 100.0;
        });
        cameraContrastSlider.addEventListener('input', (e) => {
            params.cameraContrast = parseFloat(e.target.value) / 50.0;
        });
        cameraPixelateSizeSlider.addEventListener('input', (e) => {
            params.cameraPixelateSize = parseFloat(e.target.value);
        });
        cameraBlurAmountSlider.addEventListener('input', (e) => {
            params.cameraBlurAmount = parseFloat(e.target.value);
        });
        cameraMaterialSelect.addEventListener('change', (e) => {
            const selected = e.target.value;
            params.cameraMaterialColor.copy(backgroundMaterialColors[selected]);
        });
        grayscaleToggle.addEventListener('change', (e) => {
            params.grayscale = e.target.checked;
            visualObjects.forEach((obj) => {
                if (obj.mesh && obj.mesh.material) {
                    if (obj.mesh.material.uniforms && obj.mesh.material.uniforms.grayscale) {
                        obj.mesh.material.uniforms.grayscale.value = params.grayscale;
                    } else {
                        applyMaterialColor(obj.mesh.material, obj.index);
                    }
                }
                if (obj.wireframe && obj.wireframe.material) {
                    applyMaterialColor(obj.wireframe.material, obj.index);
                }
                if (obj.points && obj.points.material) {
                    if (obj.points.geometry.attributes.color) {
                        const colors = obj.points.geometry.attributes.color.array;
                        const colorTemp = new THREE.Color();
                        for (let i = 0; i < obj.points.geometry.attributes.position.count; i++) {
                            colorTemp.copy(getCustomColor(i));
                            colors[i * 3] = colorTemp.r; colors[i * 3 + 1] = colorTemp.g; colors[i * 3 + 2] = colorTemp.b;
                        }
                        obj.points.geometry.attributes.color.needsUpdate = true;
                    } else {
                        applyMaterialColor(obj.points.material, obj.index);
                    }
                }
            });
        });
        colorInputs.forEach((input, index) => {
            input.addEventListener('input', (e) => {
                params.customColors[index] = e.target.value;
                visualObjects.forEach((obj) => {
                    if (obj.mesh && obj.mesh.material) {
                        if (obj.mesh.material.uniforms && obj.mesh.material.uniforms.customColor1) {
                            obj.mesh.material.uniforms[`customColor${index + 1}`].value.set(params.customColors[index]);
                        } else {
                            applyMaterialColor(obj.mesh.material, obj.index);
                        }
                    }
                    if (obj.wireframe && obj.wireframe.material) {
                        applyMaterialColor(obj.wireframe.material, obj.index);
                    }
                    if (obj.points && obj.points.material) {
                        if (obj.points.geometry.attributes.color) {
                            const colors = obj.points.geometry.attributes.color.array;
                            const colorTemp = new THREE.Color();
                            for (let i = 0; i < obj.points.geometry.attributes.position.count; i++) {
                                colorTemp.copy(getCustomColor(i));
                                colors[i * 3] = colorTemp.r; colors[i * 3 + 1] = colorTemp.g; colors[i * 3 + 2] = colorTemp.b;
                            }
                            obj.points.geometry.attributes.color.needsUpdate = true;
                        } else {
                            applyMaterialColor(obj.points.material, obj.index);
                        }
                    }
                });
            });
        });
        toggleAudioBtn.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'running') {
                stopAudio();
            } else {
                setupAudio(audioInputSelect.value);
            }
        });
        imageUploadInput.addEventListener('change', loadImageAsBackground);
        clearImageBtn.addEventListener('click', clearBackgroundImage);
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    let errorMessage = '¡híjole! no se pudo activar la pantalla completa.';
                    if (err.name === 'NotAllowedError') {
                        errorMessage += ' probablemente tu navegador bloqueó la solicitud. asegúrate de hacer clic en el botón directamente o revisa los permisos.';
                    } else {
                        errorMessage += ` error: ${err.message}`;
                    }
                    showMessage(errorMessage);
                });
            } else {
                document.exitFullscreen();
            }
        });
        messageBoxOkBtn.addEventListener('click', () => {
            messageBox.style.display = 'none';
        });
        midiInputSelect.addEventListener('change', (e) => {
            if (selectedMidiInput) {
                selectedMidiInput.onmidimessage = null;
            }
            const inputId = e.target.value;
            selectedMidiInput = midiInputs.get(inputId);
            if (selectedMidiInput) {
                selectedMidiInput.onmidimessage = onMidiMessage;
                showMessage(`entrada midi seleccionada: ${selectedMidiInput.name}`);
            } else {
                showMessage('no se seleccionó ninguna entrada midi.');
            }
        });
        midiChannelInput.addEventListener('change', (e) => {
            selectedMidiChannel = parseInt(e.target.value);
            if (isNaN(selectedMidiChannel) || selectedMidiChannel < 1 || selectedMidiChannel > 16) {
                selectedMidiChannel = 1;
                e.target.value = 1;
                showMessage('canal midi inválido. usando canal 1.');
            }
            showMessage(`canal midi establecido a: ${selectedMidiChannel}`);
        });
        startMidiLearnBtn.addEventListener('click', startMidiLearn);
        stopMidiLearnBtn.addEventListener('click', stopMidiLearn);
        clearMidiMappingsBtn.addEventListener('click', clearAllMidiMappings);
        jucaProfileBtn.addEventListener('click', () => navigateToPage('jucaPage'));
        maroProfileBtn.addEventListener('click', () => navigateToPage('maroPage'));
        backButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const targetPage = e.target.dataset.targetPage;
                navigateToPage(targetPage);
            });
        });
        cameraSelect.addEventListener('change', (event) => {});

        window.onload = function() {
            initFirebase();
            initThree();
            switchVisualMode(currentVisualMode);
            initMidi();
            enumerateMediaDevices();
            showMessage('¡qué onda! ¡bienvenido a tu generador de visuales! activa el audio o carga una imagen.');
            renderer.setAnimationLoop(animateMainVisualizer);
        };
    </script>
</body>
</html>
